# Chrome으로 디버깅하기

- 디버깅(debugging)
  - 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다.
  - 모던 브라우저와 호스트 환경 대부분은 도구 안에 UI 형태로 디버깅 툴을 구비해 놓는다.
  - 디버깅 툴을 사용하면 디버깅이 훨씬 쉬워지고, 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적할 수 있다.

## Sources 패널

- Chrome을 사용해 예시 페이지를 연다.
- F12(MacOS: `Cmd + Opt + I`)를 눌러 개발자 도구를 연다.
- `Sources` 탭을 클릭해 `Sources` 패널을 연다.
- 토글 버튼을 누르면 navigator가 열리면서 현재 사이트와 관련된 파일들이 나열된다.
- Sources 패널은 크게 새 개의 영역으로 구성된다.
  1. 파일 탐색 영역 - 페이지를 구성하는 데 쓰인 모든 리소스(HTML, JavaScript, CSS, 이미지 파일 등)를 트리 형태로 보여준다.  
     크롬 익스텐션이 여기 나타날 때도 있다.
  2. 코드 에디터 영역 - 리소스 영역에서 선택한 파일의 소스 코드를 보여준다.  
     여기서 소스 코드를 편집할 수도 있다.
  3. 자바스크립트 디버깅 영역 - 디버깅에 관련된 기능을 제공한다.
- 토글 버튼을 다시 누르면 리소스 영역이 사라지고, 소스 코드 영역이 더 넓어진다.

## 콘솔

- `Esc`를 누르면 개발자 도구 하단부에 콘솔 창이 열린다.
  - 여기에 명령어를 입력하고 `Enter`를 누르면 입력한 명령어가 실행된다.
- 콘솔 창에 구문을 입력하고 실행하면 아랫줄에 실행 결과가 출력된다.

## 중단점

- 코드 영역의 줄 번호를 클릭하면 중단점이 추가된다.
- 중단점(breakpoint)
  - 말 그대로 자바스크립트의 실행이 중단되는 코드 내 지점을 의미한다.
  - 중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있다.
  - 또한 실행이 중지된 시점을 기준으로 명령어를 실행할 수도 있다.
- Sources 패널 우측의 디버깅 영역을 보면 중단점 목록을 확인할 수 있다.
  - 파일 여러 개에 다수의 중단점을 설정해 놓은 경우, 디버깅 영역을 이용하면?
    - 항목을 클릭해 해당 중단점이 설정된 곳으로 바로 이동할 수 있다.
    - 체크 박스 선택을 해제해 해당 중단점을 비활성화 할 수 있다.
    - 마우스 오른쪽 버튼을 클릭했을 때 나오는 'Remove breakpoint' 옵션을 통해 중단점을 삭제할 수도 있다.
    - 이 외에도 다양한 기능이 있다.
- 조건부 중단점
  - 줄 번호에 커서를 옮긴 후 오른쪽 버튼을 클릭하면 조건부 중단점(conditional breakpoint)을 설정할 수 있다.
  - 작은 창에 표현식을 입력하면, 표현식이 참인 경우에만 실행을 중지시킬 수 있다.

## debugger 명령어

- 스크립트 내에 `debugger` 명령어를 적어주면 중단점을 설정한 것과 같은 효과를 본다.

```javascript
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- 여기서 실행이 멈춘다.

  say(phrase);
}
```

- debugger 명령어를 사용하면 브라우저를 켜 개발자 도구를 열고 소스 코드 영역을 띄워 중단점을 설정하는 수고를 하지 않아도 된다.
  - 에디터를 떠나지 않고도 중단점을 설정할 수 있어 편리하다.

## 멈추면 보이는 것들

- 중단점이 제대로 설정되어있는지 확인하고, 새로고침 단축키 `F5` or `Cmd+R`키를 눌러 중단점을 작동시킨다.
  - 중단점에서 실행이 중단되는 것을 확인할 수 있다.
- 디버깅 영역에서 하위 패널들을 펼쳐볼 수 있다. 각 패널은 아래와 같은 기능을 제공한다.
  1. `Watch` = 표현식을 평가하고 결과를 보여준다.
     - Add Expression 버튼 `+`을 클릭해 원하는 표현식을 입력한 후 `Enter`키를 누르면 중단 시점의 값을 보여준다.
     - 입력한 표현식은 실행 과정 중에 계속해서 재평가된다.
  2. `Call Stack` - 코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시한다.
     - 콜 스택 내의 항목을 클릭하면 디버거가 해당 코드로 움직이고, 변수 역시 재평가된다.
  3. `Scope` - 현재 정의된 모든 변수를 출력한다.
     - `Local`은 함수의 지역 변수를 보여준다.  
       지역 변수 정보는 소스 코드 영역에서도 확인할 수 있다.(강조표시)
     - `Global`은 함수 바깥에 정의된 전역 변수를 보여준다.

## 실행 추적하기

- `Resume` : 스크립트 실행을 다시 시작함 (단축키 `F8`)
  - 실행을 재개한다. 추가 중단점이 없는 경우, 실행이 쭉 이어지고 디버거는 동작하지 않는다.
- `Step` : 다음 명령어를 실행함 (단축키 `F9`)
  - 다음 문을 실행한다.
  - 계속 누르면 스크립트 전체를 문 단위로 하나하나 실행할 수 있다.
- `Step over` : 다음 명령어를 실행하되, 함수 안으로 들어가진 않음 (단축키 `F10`)
  - Step과 유사하지만 다음 문이 함수 호출일 때 Step과는 다르게 동작한다.(직접 작성한 함수일 때만)
  - Step은 함수 내부로 들어가 함수 본문 첫 번째 줄에서 실행을 멈춘다.
    - 반면 `Step over`는 보이지 않는 곳에서 중첩 함수를 실행하긴 하지만 함수 내로 진입하지 않는다.
  - 실행은 함수 실행이 끝난 후에 즉시 멈춘다.
- `Step into` : (단축키 `F11`)
  - Step과 유사한데, 비동기 함수 호출에서 Step과는 다르게 동작한다.
  - Step은 `setTimeout`같은 비동기 동작은 무시한다.
    - 반면 Step into는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 비동기 동작이 완료될 때까지 대기한다.
- `Step out` : 실행 중인 함수의 실행이 끝날 때 까지 실행을 계속함 (단축키 `Shift + F11`)
  - 현재 실행 중인 함수의 실행을 계속 이어가다가 함수 본문 마지막 줄에서 실행을 멈춘다.
  - 실수로 Step을 눌러 내부 동작을 알고 싶지 않은 중첩 함수로 진입했거나 가능한 한 빨리 함수 실행을 끝내고 싶은 경우 유용
- 모든 중단점을 활성화/비활성화
  - 모든 중단점을 일시적으로 활성화/비활성화 한다(실행에는 영향이 없다).
- 예외 발생 시 코드를 자동 중지시켜주는 기능을 활성화/비활성화
  - 활성화되어 있고, 개발자 도구가 열려있는 상태에서 실행 중에 에러가 발생하면 실행이 자동으로 멈춘다.
  - 실행이 중단되었기 때문에 변수 등을 조사해 어디서 에러가 발생했는지 찾을 수 있게 된다.
  - 개발하다가 에러와 함께 스크립트가 죽으면 디버거를 열고 이 옵션을 활성화한 후,  
    페이지를 새로 고침하면 에러가 발생한 곳과 에러 발생 시점의 컨텍스트를 확인할 수 있다.
- Continue to here 옵션
  - 특정 줄에서 마우스 오른쪽 버튼을 클릭해 컨텍스트 메뉴를 열면 "Continue to here" 옵션을 볼 수 있다.
  - 중단점을 설정하기는 귀찮은데 해당 줄에서 실행을 재개하고 싶을 때 아주 유용한 옵션

## console.log

- `console.log` 함수를 이용하면 원하는 것을 콘솔에 출력할 수 있다.

```javascript
// 콘솔창에 0부터 4까지 출력
for (let i = 0; i < 5; i++) {
  console.log("숫자", i);
}
```

- 결과는 콘솔창에만 있기 때문에 일반 사용자는 결과를 볼 수 없다.
  - 결과를 보려면 개발자 도구의 콘솔 패널을 직접 열거나 다른 패널이 열린 상태에서 `Esc`를 눌러 화면 하단에 콘솔 패널을 띄우면 된다.
- 코드에 `console.log`를 적절히 넣어주었다면 디버거 없이도 무슨 일이 일어나고 있는지 충분히 파악할 수 있다.
  - `console.log`함수와 디버거를 적절히 활용하자.

# 코딩 스타일

- 개발자는 가능한 한 간결하고 읽기 쉽게 코드를 작성해야 한다.

## 문법

### 중괄호

- 대부분의 자바스크립트 프로젝트에서 여는 중괄호는 이집션(Egyptian) 스타일을 따라 새로운 줄이 아닌 상응하는 키워드와 같은 줄에 작성한다.
  - 여기에 더해 여는 중괄호 앞엔 공백이 하나 있어야 한다.

```javascript
if (condition) {
  // 코드 1
  // 코드 2
  // ...코드 n...
}
```

### 가로 길이

- 가로로 길게 늘어진 코드를 읽는 걸 좋아하는 개발자는 없다.
  - 코드의 가로 길이가 길어지면 여러 줄로 나눠 작성하는 게 좋다.

```javascript
// 백틱(`)을 사용하면 문자열을 여러 줄로 쉽게 나눌 수 있다.
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;

// if문 일 때
if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
```

- 최대 가로 길이는 팀원들과 합의해 정하는게 좋다.
  - 대개 80자나 120자로 제한하는 게 일반적이다.

### 들여쓰기

- 들여쓰기에는 두 종류가 있다.

  1. 가로 들여쓰기 : 스페이스 두 개 혹은 네 개를 사용해 만든다.

     - 가로 들여쓰기는 스페이스 두 개 혹은 네 개를 사용하거나 탭 키(`Tab`)를 이용해 만들 수 있다.

     - 어떤 방법을 쓸지에 대한 논쟁은 오래전부터 있었는데, 요즘엔 탭 대신 스페이스를 이용하는 게 더 우위?

     - 탭 대신 스페이스를 이용했을 때의 장점 중 하나는 들여쓰기 정도를 좀 더 유연하게 변경할 수 있다는 점.

       ```javascript
       // 인수 모두의 위치를 여는 괄호와 맞출 수 있다.
       show(parameters,
            aligned, // 스페이스 다섯 개를 이용해 들여쓰기 함
            one,
            after,
            another
         ) {
         // ...
       }
       ```

  2. 세로 들여쓰기 : 논리 블록 사이에 넣어 코드를 분리해주는 새 줄

     - 함수 하나에 논리 블록 여러 개가 들어갈 수 있다.

       ```javascript
       // 변수 선언, 반복문, 리턴문 사이에 세로 들여쓰기를 해주는 빈 줄을 넣음
       function pow(x, n) {
         let result = 1;
         //              <--
         for (let i = 0; i < n; i++) {
           result *= x;
         }
         //              <--
         return result;
       }
       ```

     - 여분의 줄을 넣어주면 코드의 가독성이 좋아진다.

     - 읽기 쉬운 코드를 만들려면 세로 들여쓰기 없이 코드를 아홉 줄 이상 연속해서 쓰지말자.

### 세미콜론

- 자바스크립트 엔진에 의해 무시되더라도 모든 구문의 끝엔 세미콜론을 써주는 것이 좋다.
- 자바스크립트에선 줄 바꿈이 세미콜론으로 해석되지 않는 몇몇 상황이 있기 때문에 세미콜론을 생략하고 코딩한다면?
  - 에러를 발생시키는 코드를 만들 수 있다.

### 중첩 레벨

- 가능하면 너무 깊은 중첩문은 사용하지 않도록 한다.
  - 반복문을 사용할 때 중첩문의 깊이가 깊어지면 `continue` 지시자를 쓰는 게 좋은 대안이 될 수도 있다.

```javascript
// if 문으로 조건을 처리하는 예시
for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- 중첩 레벨이 하나 더 늘어났다.
  }
}
// continue를 써서 바꾼 예시
for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- 추가 중첩 레벨이 추가되지 않는다.
}
```

- `if / else`와 `return`문을 조합하면 중첩 레벨을 줄여 코드의 가독성을 높일 수 있다.

```javascript
// 예시 두개는 모두 동일하게 동작

// 1
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}

// 2
function pow(x, n) {
  if (n < 0) {
    alert("'n'은 음수가 될 수 없습니다.");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

## 함수의 위치

- 헬퍼 함수 여러 개를 만들어 사용하고 있다면?

```javascript
// 1. 헬퍼 함수를 사용하는 코드 위에서 헬퍼 함수를 모아 선언하기
// 함수 선언
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// 헬퍼 함수를 사용하는 코드
let elem = createElement();
setHandler(elem);
walkAround();
    
// 2. 코드를 먼저, 함수는 그 다음에 선언하기
// 헬퍼 함수를 사용하는 코드
let elem = createElement();
setHandler(elem);
walkAround();

// --- 헬퍼 함수 ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
  
// 3. 코드 바로 위에서 필요한 헬퍼 함수 그때그때 선언하기
```

- 대개 두 번째 방법으로 코드를 정돈하는 걸 선호한다.
  - 사람들은 코드를 이 코드가 '무엇을 하는지'를 생각하며 코드를 읽기 때문에 코드가 먼저 나오는 것이 자연스럽기 때문이다.
  - 이름만 보고도 헬퍼 함수의 역할을 쉽게 유추할 수 있게 헬퍼 함수 이름을 명명했다면 함수 본문을 읽을 필요도 없다.

## 스타일 가이드

- 어떻게 작성할지에 대한 전반적인 규칙을 담은 문서
- 팀원 전체가 동일한 스타일 가이드를 따라 코드를 작성하면?
  - 누가 코드를 작성했냐에 관계없이 동일한 스타일의 코드를 만들 수 있다.
- 유명 스타일 가이드
  - [Google의 자바스크립트 스타일 가이드](https://google.github.io/styleguide/javascriptguide.xml)
  - [Airbnb의 자바스크립트 스타일 가이드](https://github.com/airbnb/javascript)
  - [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)
  - [StandardJS](https://standardjs.com/)
  - 기타 등등

## Linter

- Linter라는 도구를 사용하면 내가 작성한 코드가 스타일 가이드를 준수하고 있는지를 자동으로 확인할 수 있고,  
  스타일 개선과 관련된 제안도 받을 수 있다.
- 자동으로 스타일을 체크받다 보면 변수나 함수 이름에 난 오타 등이 유발하는 버그를 미리 발견할 수 있어 좋다.
- 유명 linter:
  - [JSLint](http://www.jslint.com/) – 역사가 오래된 linter
  - [JSHint](http://www.jshint.com/) – JSLint보다 세팅이 좀 더 유연한 linter
  - [ESLint](http://eslint.org/) – 가장 최근에 나온 linter
- 대부분의 linter는 플러그인 형태로 유명 에디터와 통합해 사용할 수 있다.
  - 원하는 스타일을 설정하는 것 역시 가능하다.
- ESLint를 사용한다고 가정했을 때 에디터와 linter를 통합하는 법
  1. [Node.js](https://nodejs.org/)를 설치한다.
  2. npm(자바스크립트 패키지 매니저)을 사용해 다음 명령어로 ESLint를 설치한다. `npm install -g eslint`
  3. 현재 작성 중인 자바스크립트 프로젝트의 루트 폴더(프로젝트 관련 파일이 담긴 폴더)에 `.eslintrc`라는 설정 파일을 생성한다.
  4. 에디터에 ESLint 플러그인을 설치하거나 활성화한다. 주요 에디터들은 모두 ESLint 플러그인을 지원한다.

```
// .eslintrc 파일의 예시
{
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": ["warning", 2]
  }
}
```

# 주석

- 주석은 어떻게 코드가 동작하는지, 왜 코드가 동작하는지를 설명하는 데 쓰인다.

## 좋지 않은 주석

- 좋은 코드엔 설명이 담긴 주석이 많아선 안 된다.
  - 주석 없이 코드 자체만으로 코드가 무슨일을 하는지 쉽게 이해할 수 있어야 한다
- 코드가 불분명해서 주석 작성이 불가피하다면 코드를 다시 작성해야 하는 지경에 이른 걸 수 있다.

### 리팩토링 팁 : 함수 분리하기

- 함수 내 코드 일부를 새로운 함수로 옮기는 게 유익할 때도 있다.

```javascript
function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // i가 소수인지를 확인함
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
// 코드 일부를 함수 isPrime으로 옮기면 더 나은 코드를 작성할 수 있다.
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
// 함수 이름 자체가 주석 역할을 하게 되므로 코드를 쉽게 이해할 수 있다.
// 이런 코드를 자기 설명적인 코드라 부른다.
```

### 리팩토링 팁 : 함수 만들기

```javascript
// 코드가 아래로 죽 늘어져 있는 경우
// 위스키를 더해줌
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// 주스를 더해줌
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
```

- 새로운 함수를 만들고, 코드 일부를 새로 만든 함수에 옮기는 게 좋다.

```javascript
addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
```

- 함수는 주석이 없어도 그 존재 자체가 무슨 역할을 하는지 설명할 수 있어야 한다.
  - 코드를 분리해 작성하면 더 나은 코드 구조가 된다.
  - 가이드를 잘 지켜 코드를 작성하면 함수가 어떤 동작을 하는지, 무엇을 받고 무엇을 반환하는지가 명확해진다.
- 실무에선 설명이 담긴 주석을 작성하는 게 불가피한 경우도 있다.
  - 알고리즘이 복잡한 코드를 작성하는 경우나 최적화를 위해 코드를 약간 비틀어 작성할 땐 설명을 적어주어야 한다.
  - 이런 경우를 제외하곤 간결하고 코드 자체만으로 설명이 가능하게 코딩해야 한다.

## 좋은 주석

- 아키텍쳐를 설명하는 주석
  - 고차원 수준 컴포넌트 개요, 검포턴트 간 상호작용에 대한 설명, 상황에 따른 제어 흐름 등은 주석에 넣는 게 좋다. 
- 함수 용례와 매개변수 정보를 담고 있는 주석
  - [JSDoc](http://en.wikipedia.org/wiki/JSDoc)이라는 특별한 문법을 사용하면 함수에 관한 문서를 쉽게 작성할 수 있다.
    - 여기엔 함수 용례, 매개변수, 반환 값 정보가 들어간다.

```javascript
/**
 * x를 n번 곱한 수를 반환함
 *
 * @param {number} x 거듭제곱할 숫자
 * @param {number} n 곱할 횟수, 반드시 자연수여야 함
 * @return {number} x의 n 거듭제곱을 반환함
 */
function pow(x, n) {
  ...
}
// 이런식으로 주석을 달면 코드를 읽어보지 않고도 함수의 목적과 사용법을 한눈에 알 수 있다.
```

- 왜 이런 방법으로 문제를 해결했는지를 설명하는 주석
  - 무엇이 적혀있는지는 중요한데, 무슨 일이 일어나고 있는지 파악하려면 무엇이 적혀있지 않은 지가 더 중요할 수 있다.
    - 왜 이 문제를 이런 방법으로 해결했냐? 라는 질문에 코드는 답을 해 줄 수 없기 때문
  - 문제 해결 방법이 여러 가지인데 왜 하필이면 이 방법을 택했는지 의문이 들 때가 있다.
    - 왜 이런 방법을 써서 문제를 해결했는지 알려주는 주석이 없으면 아래와 같은 일이 발생할 수 있다.
      1. 당신(혹은 동료)은 작성된 후 시간이 꽤 흐른 코드를 열어본다.  
         그리고 그 코드에서 선택한 방식이 '가장 좋은 방식'은 아니란걸 알아낸다.
      2. '그때는 내가 멍청했구나. 하지만 지금은 더 똑똑해졌지' 라고 생각하며,  
         이전보단 더 명확하고 올바른 방법으로 코드를 개선한다.
      3. 코드를 개선하려는 시도까지는 좋았으나,  
         리팩토링 과정에서 '더 명확'하다고 생각했던 방법을 적용하면 문제가 발생한다는걸 알아낸다.  
         이미 시도해봤던 방법이기 때문에 왜 이 방법이 먹히지 않는지 희미하게 기억이 떠오른다.  
         새로 작성한 코드를 되돌렸지만, 시간이 낭비되게된다.
  - 해결 방법을 담고 있는 주석은 아주 중요한 역할을 한다.
    - 이전에 했던 실수를 방지하는 안내판 역할을 하기 때문
- 미묘한 기능이 있고, 이 기능이 어디에 쓰이는지를 설명하는 주석
  - 직감에 반하는 미묘한 동작을 수행하는 코드가 있다면 주석을 달아주는 게 좋다.



# 테스트 자동화와 Mocha

## 테스트는 왜 해야 하는가?

- 함수를 하나 만들고 있다고 가정
  - 대부분 매개변수 - 결과 관계를 중심으로 어떻게 코드를 작성할지 구상한다.
- 개발 중엔 콘솔 창 등을 이용해 실제 실행 결과가 기대했던 결과와 같은지 계속 비교하면서 원하는 기능이 잘 구현되고 있는지 확인할 것이다.
  - 기대했던 결과와 다를 땐, 코드를 수정하고 다시 실행해 기대했던 결과와 다시 비교해 볼 것이다.
  - 이렇게 수동으로 코드를 재실행하는 건 상당히 불완전하다.

- <b>코드를 수동으로 재실행하면서 테스트를 하면  무언가를 놓치기 쉽다.</b>

- 함수 `f`를 구현하고 있다고 가정
  - 코드를 작성하고 `f(1)`이 제대로 동작하는지 확인한다.
  - 제대로 동작하는데 `f(2)`를 테스트해 보니 제대로 동작하지 않는다.
  - 코드를 수정한 후 다시 `f(2)`를 확인해 보아 제대로 동작하는 걸 확인한다.
  - 끝나지 않았다. `f(1)`이 제대로 동작하는지 확인하지 않았다.
    - 이런식으로 테스트를 수동으로 하면 에러가 발생할 여지를 남긴다.
- 개발자는 무언가를 만들 때 머릿속에 수많은 유스 케이스를 생각하며 코드를 작성하는데,  
  코드를 변경해야 할 때마다 모든 유스 케이스를 상기하면서 코드를 수정하는 것은 거의 불가능하다.
  - 하나를 고치면 또 다른 문제가 튀어나오는 이유가 바로 이 때문

- <b>테스팅 자동화는 테스트 코드가 실제 동작에 관여하는 코드와 별개로 작성되었을 때 가능하다.  
  테스트 코드를 이용하면 함수를 다양한 조건에서 실행해 볼 수 있는데, 이때 실행 결과와 기대 결과를 비교할 수 있다.</b>

## Behavior Driven Development

- BDD라 불리는 방법론
  - BDD는 테스트, 문서, 예시를 한데 모아놓은 개념이다.

## 거듭제곱 함수와 명세서

- `x`를 `n`번 곱해주는 함수 `pow(x, n)`를 구현하고 있다고 가정
  - 사실 자바스크립트엔 거듭제곱 연산자 `**`가 있지만 직접 함수를 구현하는 이유
    - 구현 과정에 초점을 두면서 BDD를 직접 적용해 보기 위해
- 본격적으로 코드를 작성하기 전에 먼저 해야 할 것
  - 코드가 무슨 일을 하는지 상상한 후 이를 자연어로 표현해야 한다.
- 이때 만들어진 산출물을 BDD에선 명세서 또는 짧게 줄여 스펙이라고 부른다.
  - 명세서엔 유스 케이스에 대한 자세한 설명과 테스트가 담겨 있다.

```javascript
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

- 스펙은 세 가지 주요 구성 요소로 이루어진다.
  - `describe("title", function() { ... })`  
    구현하고자 하는 기능에 대한 설명이 들어간다.  
    위 예시에선 함수 `pow`가 어떤 동작을 하는지에 대한 설명이 들어갈 것
  - `it("유스 케이스 설명", function() { ... })`  
    `it`의 첫 번째 인수엔 특정 유스 케이스에 대한 설명이 들어간다.  
    이 설명은 누구나 읽을 수 있고 이해할 수 있는 자연어로 적어준다.  
    두 번째 인수엔 유스 케이스 테스트 함수가 들어간다.
  - `assert.equal(value1, value2)`  
    기능을 제대로 구현했다면 `it` 블록 내의 코드 `assert.equal(value1, value2)`이 에러 없이 실행된다.  
    함수 `assert.*`는 `pow`가 예상한 대로 동작하는지 확인해준다.  
    예시의 `assert.equal`함수는 인수끼리 동등 비교했을 때 다르다고 판단되면 에러를 반환한다.
- 명령어는 실행 가능하다.
  - 명세서를 실행하면 `it` 블록 안의 테스트가 실행된다.

## 개발 순서

- 실제 개발에 착수하면 아래와 같은 순서로 개발이 진행된다.

1. 명세서 초안을 작성한다. 초안엔 기본적인 테스트도 들어간다.
2. 명세서 초안을 보고 코드를 작성한다.
3. 코드가 작동하는지 확인하기 위해 [Mocha](http://mochajs.org/)라 불리는 테스트 프레임워크를 사용해 명세서를 실행한다.  
   이때, 코드가 잘못 작성되었다면 에러가 출력된다.  
   개발자는 테스트를 모두 통과해 에러가 더는 출력되지 않을 때까지 코드를 수정한다.
4. 모든 테스트를 통과하는 코드 초안이 완성된다.
5. 명세서에 지금까지 고려하지 않았던 유스케이스 몇 가지를 추가한다. 테스트가 실패하기 시작한다.
6. 세 번째 단계로 돌아가 테스트를 모두 통과할 때까지 코드를 수정한다.
7. 기능이 완성될 때까지 3~6단계를 반복한다.

# 폴리필

- 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다.
- 자바스크립트는 끊임없이 진화하는 언어이다.
  - 새로운 제안이 정기적으로 등록, 분석되고, 가치가 있다고 판단되는 제안은 https://tc39.github.io/ecma262/ 에 추가된다.
  - 그리고 궁극적으로 명세서에 등록된다.
- 자바스크립트 엔진을 만드는 각 조직은 나름대로 우선순위를 매겨 명세서 내 어떤 기능을 먼저 구현할지 결정한다
  - 명세서에 등록된 기능보다 초안에 있는 제안을 먼저 구현하기로 결정하는 경우도 있다.
    - 구현 난이도가 높아서일 수도 있지만, 구미를 당기지 않아서 이런 결정을 내리기도 한다.
  - 엔진이 표준 전체를 지원하지 않고 일부만 지원하는 건 흔한 일
- 엔진별로 어떤 기능을 지원하고 있는지는 https://kangax.github.io/compat-table/es6/ 에서 확인할 수 있다.

## 바벨

- 명세서에 등록된 지 얼마 안 된 기능을 사용해 코드를 작성하다 보면 특정 엔진에서 작성한 코드를 지원하지 않는다는 걸 알게 되는 경우가 있다.
  - 명세서 내 모든 기능을 엔진이 구현하고 있지 않기 때문
  - 이럴 때 바벨을 사용할 수 있다.
- 바벨(babel)은 트랜스파일러(transpiler)로, 모던 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔준다.
- 바벨의 주요 역할
  1. 트랜스파일러 - 바벨은 코드를 재작성해주는 트랜스파일러 프로그램이다.  
     바벨은 개발자의 컴퓨터에서 돌아가는데, 이를 실행하면 기존 코드가 구 표준을 준수하는 코드로 변경된다.  
     변경된 코드는 웹사이트 형태로 사용자에게 전달된다.  
     [웹팩(webpack)](http://webpack.github.io/)과 같은 모던 프로젝트 빌드 시스템은 코드가 수정될 때마다 자동으로 트랜스파일러를 동작시켜 준다.  
     이런 과정이 없으면 개발이 끝난 코드를 한데 통합하는 데 어려움이 있을 수 있다.
  2. 폴리필
     - 명세서엔 새로운 문법이나 기존에 없던 내장 함수에 대한 정의가 추가되곤 한다.  
       새로운 문법을 사용해 코드를 작성하면 트랜스파일러는 이를 구 표준으로 준수하는 코드로 변경해준다.  
       반면, 새롭게 표준에 추가된 함수는 명세서 내 정의를 읽고 이에 맞게 직접 함수를 구현해야 사용할 수 있다.  
       자바스크립트는 매우 동적인 언어라서 원하기만 하면 어떤 함수라도 스크립트에 추가할 수 있다.  
       기존 함수를 수정하는 것도 가능하다.  
       개발자는 스크립트에 새로운 함수를 추가하거나 수정해서 스크립트가 최신 표준을 준수 할 수 있게 작업할 수 있다.
     - 이렇게 변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나,  
       새롭게 구현한 함수의 스크립트를 폴리필이라 부른다.  
       폴리필은 말 그대로 구현이 누락된 새로운 기능을 매꿔주는(fill in) 역할을 한다.
     - 주목할 만한 폴리필 두 가지
       - [core js](https://github.com/zloirock/core-js) – 다양한 폴리필을 제공. 특정 기능의 폴리필만 사용하는 것도 가능.
       - [polyfill.io](http://polyfill.io/) – 기능이나 사용자의 브라우저에 따라 폴리필 스크립트를 제공해주는 서비스.
- 모던 자바스크립트를 이용해 스크립트를 작성하려면 트랜스파일러와 폴리필은 필수이다.