# Hello, world!

## 'script' 태그

- \<script> 태그를 이용하면 자바스크립트 프로그램을 HTML문서 어느 곳에나 삽입할 수 있다.

```html
<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Document</title>
</head>
<body>
<p>스크립트 전</p>

    <script>
      alert('Hello, world!');
    </script>

<p>스크립트 후</p>
</body>
</html>
<html>
```

- 브라우저가 script태그를 만나면 자동으로 처리

## 모던 마크업

- `<script>` 태그엔 몇 가지 속성(attribute)이 있다.
  - 오래된 코드에서 종종 발견할 수 있다. 요즘엔 잘 사용하지 않음
  - type 속성 : `<script type=...>`
    - HTML4에선 스크립트에 type을 명시하는 것이 필수였다.
    - type="text/javascript" 속성이 붙은 스크립트를 어렵지 않게 찾을 수 있었다.
    - 하지만 이제 타입 명시가 필수가 아니다.
    - 모던 HTML 표준에선 이 속성의 의미가 바뀌었다.
  - language 속성 : `<script language=...>`
    - 현재 사용하고 있는 스크립트 언어를 나타낸다.
    - 지금은 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색된 상황. 더는 사용할 필요가 없어졌다.
  - 스크립트 전후에 위치한 주석
    - `<script>` 태그를 처리하지 못하는 브라우저가 해당 스크립트를 읽지 못하게 하려고 사용했었다.
    - 지난 15년간 출시된 브라우저는 스크립트 태그를 처리할 수 있다.

## 외부 스크립트

- 자바스크립트 코드의 양이 많은 경우, 파일로 소분하여 저장할 수 있다.
  - 분해해 놓은 각 파일은 `src` 속성을 사용해 HTML에 삽입한다.

```html
<script src="/path/to/script.js"></script>
```

- `/path/to/script.js`는 사이트의 루트에서부터 파일이 위치한 절대 경로를 나타낸다.
  - 현재 페이지에서 상대 경로를 사용하는 것도 가능하다.
    - 같은 폴더 내에 있는 파일인 참조하는 것처럼.
  - URL 전체를 속성으로 사용할 수도 있다.

```html
<script src="https://....js"></script>
```

- 복수의 스크립트를 HTML에 삽입하고 싶다면?
  - 스크립트 태그를 여러 개 사용하면 된다.

```html
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
...
```

- 주의
  - HTML 안에 직접 스크립트를 작성하는 방식은 스크립트가 아주 간단할 때만 사용.  
    스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋다.
  - 스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 캐시(cache)에 저장하기 때문에 성능상의 이점이 있다.
  - 여러 페이지에서 동일한 스크립트를 사용하는 경우, 브라우저는 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않는다.
    - 캐시로부터 스크립트를 가져와 사용한다.
    - 스크립트 파일을 한 번만 다운받으면 된다.
  - 이를 통해 트래픽이 절약되고 웹 페이지의 속도가 빨라진다.
- `src` 속성이 있으면 태그 내부의 코드는 무시된다.
  - `<script>` 태그는 `src` 속성과 내부 코드를 동시에 가지지 못한다.

```html
<script src="file.js">
	alert(1); // src 속성이 사용되었으므로 코드가 무시됨
</script>
```

- 외부 파일을 연결할지, 태그 내에 코드를 작성할지 선택해야 한다.
  - 스크립트 두 개로 분리하면 정상 실행된다.

```html
<script src="file.js"></script>
<script>
	alert(1);
</script>
```

# 코드 구조

## 문

- 문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미한다.
  - 'Hello, world!' 메시지를 보여주는 `alert('Hello, world!')`문
- 코드엔 원하는 만큼 문을 작성할 수 있다.
  - 서로 다른 문은 세미콜론으로 구분한다.

```javascript
// 'Hello, World'를 두 개의 alert 문으로 나눈 예시
alert('Hello'); alert('World');
// 코드의 가독성을 높이기 위해 각 문은 서로 다른 줄에 작성하는 것이 일반적
alert('Hello');
alert('World');
```

## 세미콜론

- 줄 바꿈이 있다면 세미콜론(semicolon)을 생략할 수 있다.

```javascript
alert('Hello')
alert('World')
```

- 자바스크립트는 줄 바꿈이 있으면 '암시적' 세미콜론으로 해석한다.
  - 이런 동작 방식을 세미콜론 자동 삽입이라 부른다.
  - 대부분의 경우 줄 바꿈은 세미콜론을 의미하지만, 항상을 의미하지는 않는다.

```javascript
// 줄 바꿈이 세미콜론을 의미하지 않는 경우도 있다.
alert(3 +
     1
     + 2);
```

- 세미콜론 자동 삽입이 일어나지 않았기 때문에 6이 출력된다.
  - 어떤 줄이 `"+"`로 끝나면, 그 줄은 '불완전한 표현식' 이므로 세미콜론이 필요하지 않다.
  - 세미콜론이 정말 필요하지만 자바스크립트가 이를 추정하지 못하는 상황도 존재

```javascript
// 에러 예제
[1, 2].forEach(alert) // 결과는 1과 2가 출력됨

// 앞쪽에 세미콜론을 붙이지 않은 채 alert를 추가할 시
alert("에러가 발생합니다.")
[1, 2].forEach(alert)
// 새로 추가한 alert만 제대로 출력된다.

// alert 끝에 세미콜론을 추가해 다시 실행하면 잘 작동한다.
alert("에러가 발생합니다.");
[1, 2].forEach(alert)
```

- 세미콜론이 없을 때 에러가 발생했던 이유
  - 자바스크립트가 대괄호 [ ... ] 앞에는 세미콜론이 있다고 가정하지 않기 때문이다.
    - 따라서 세미콜론 자동 삽입이 일어나지 않게 된다.
    - 예제는 단일 문으로 처리된다.

```javascript
alert("에러가 발생합니다.")[1, 2].forEach(alert)
// 원래는 두 개의 서로 다른 문이였다.
```

- 줄 바꿈으로 문을 나눴더라도 문 사이엔 세미콜론을 넣는 것이 좋다.

## 주석

- 무슨일이 왜 벌어지고 있는지를 설명해주는 주석(comment)
  - 스크립트 어느 곳에나 작성할 수 있다.
  - 자바스크립트 엔진은 주석을 무시하기 때문에 주석의 위치는 실행에 영향을 주지 않는다.

```javascript
// 한 줄 다 차지하는 주석
alert('Hello');

alert('World'); // 문 다음 이어지는 주석
```

- 여러 줄의 주석은 `/*`로 시작해 `*/`로 끝난다.

```javascript
/* 두 줄 짜리 주석 예제
이것은 여러 줄의 주석
*/
alert('Hello');
alert('World');
```

- 코드를 일시적으로 비활성화할 수 있다.

```javascript
/* 코드 주석 처리하기
alert('Hello');
*/
alert('World');
```

- 중첩 주석은 지원하지 않는다.
  - `/* ... */` 안에 또 다른 `/* ... */`이 있을 수 없다.
  - 주석을 중첩해서 쓰면 에러가 발생한다.

# 엄격 모드

- 자바스크립트는 오랫동안 호환성 이슈 없이 발전해왔다.
  - 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었다.
  - 기존에 작성한 코드는 절대 망가지지 않는다는 장점이 있다.  
    하지만 자바스크립트 창시자들이 했던 실수나 불완전한 결정이 언어 안에 영원히 박제된다는 단점도 생겼다.
  - 이런 상황은 ECMAScript(ES5)가 등장하기 전인 2009년까지 지속되었다.
  - 새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다.
    - 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있다.
    - 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었다.
    - use strict라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 변경사항이 활성화되게 해 놓았다.

## use strict

- 지시자 `"use strict"`, 혹은 `'use strict'`는 단순한 문자열처럼 생겼다.
  - 하지만 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 "모던한" 방식으로 동작한다.

```javascript
"use strict";
// 코드가 모던한 방식으로 실행된다.
...
```

- `"use strict"`는 스크립트 최상단이 아닌 함수 본문 맨 앞에 올 수도 있다.
  - 엄격 모드는 대개 스크립트 전체에 적용하지만, 이렇게 하면 오직 해당 함수만 엄격 모드로 실행된다.
- "use strict"는 반드시 최상단에 위치시켜야 한다.
  - 엄격 모드가 활성화 되지 않을 수도 있다.

```javascript
alert("some code");
// 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시된다.

"use strict";
// 엄격 모드가 활성화되지 않음.
```

- `"use strict"`의 위에는 주석만 사용할 수 있다.
- `"use strict"`를 취소할 방법은 없다.

## 브라우저 콘솔

- 개발한 기능을 테스트하기 위해 브라우저 콘솔을 사용하는 경우, 기본적으로 "use strict"가 적용되어있지 않다.
  - `use strict`에 영향을 받는 경우라면 개발자는 기대하지 않았던 결과를 얻을 수 있기 때문
- 어떻게 해야 콘솔에서 `use strict`를 사용할까?
  - 'use strict'를 입력한 후, `Shift+Enter`키를 눌러 줄 바꿈 하여 원하는 스크립트를 입력하면 된다.

```javascript
'use strict'; <Shift+Enter를 눌러 줄 바꿈 한다.>
// ... 테스트 하려는 코드 입력
<Enter를 눌러 실행>
```

- Firefox와 Chrome같은 유명한 브라우저에서 대부분 사용 가능하다.
- 브라우저가 오래 되어서 콘솔 창에 `use strict`를 입력하는게 불가능하다면?
  - `use strict`를 적용하는 가장 확실한 방법은 코드를 래퍼로 감싸면 된다.

```javascript
(function() {
    'use strict';
    
    // ... 테스트하려는 코드 ...
})()
```

## 'use strict'를 꼭 사용해야 할까?

- 모던 자바스크립트는 '클래스'와 '모듈' 이라 불리는 진일보한 구조를 제공한다.
  - 이 둘을 사용하면 use strict가 자동으로 적용된다.
  - 스크립트에 `"use strict"`를 붙일 필요가 없다.
  - 즉, 코드를 클래스와 모듈을 사용해 구성한다면`"use strict"`를 생략해도 된다.

# 변수와 상수

## 변수

- 변수(variable)
  - 데이터를 저장할 때 쓰이는 '이름이 붙은 저장소'
  - 자바스크립트에선 let 키워드를 사용해 변수를 생성한다.

```javascript
// 'message'라는 이름을 가진 변수를 생성(선언)하는 문
let message;
```

- 할당 연산자 `=`를 사용해 변수 안에 데이터를 저장한다.

```javascript
let message;

message = 'Hello'; // 문자열을 저장
```

- 변수명을 이용해 문자열에 접근할 수 있게 되었다.

```javascript
let message;
message = 'Hello!';

alert(message); // 변수에 저장된 값을 보여준다.
```

- 변수 선언과 값 할당을 한 줄에 작성할 수도 있다.

```javascript
let message = 'Hello!'; // 변수를 정의하고 값을 할당한다.
alert(message); // Hello!
```

- 한 줄에 여러 변수를 선언하는 것도 가능하다.

```javascript
let user = 'John', age = 25, message = 'Hello';
// 코드가 더 짧아 보이긴 하지만 권장하지 않는 방법.
// 가독성을 위해 한 줄에는 하나의 변수를 작성하는게 읽기에 편하다.
let user = 'John';
let age = 25;
let message = 'Hello';
```

- 변수 정의의 다른 방식

```javascript
let user = 'John',
    age = 25,
    message = 'Hello';

// 쉼표가 먼저 오는 방식
let user = 'John'
    , age = 25
    , message = 'Hello';
```

- 오래된 스크립트에서 `let`대신 `var`라는 키워드가 발견되는 경우
  - `var`는 `let`과 거의 동일하게 동작한다.
    - `var`는 오래된 방식

---

- 함수형 언어
  - 함수형 프로그래밍 언어는 변숫값 변경을 금지한다.
    - 스칼라(Scala)와 얼랭(Erlang)은 대표적인 함수형 언어
  - 값이 일단 저장되면, 그 값을 영원히 유지한다.  
    다른 값을 저장하고 싶다면 새 변수를 선언해야만 한다.
  - 함수형 언어는 중대한 개발에 상당히 적합한 언어이다.

---

## 변수 명명 규칙

- 자바스크립트에서 변수 명명 시 두 가지 제약 사항
  1. 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있다.
  2. 첫 글자는 숫자가 될 수 없다.

```javascript
// 유효한 변수명의 예시
let userName;
let test123;
```

- 여러 단어를 조합해 변수명을 만들 땐 카멜 표기법(camelCase)가 흔히 사용된다.
  - 단어를 차례대로 나열하면서 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성

```javascript
// 유효한 변수명의 예시
let $ = 1; // '$'라는 이름의 변수를 선언
let _ = 2; // '_'라는 이름의 변수를 선언

alert($ + _); // 3
```

```javascript
// 잘못된 변수명의 예시
let 1a; // 변수명은 숫자로 시작해선 안 된다.
let my-name; // 하이픈 '-'은 변수명에 올 수 없다.
```

- 대 / 소문자를 구별한다.
  - apple과 AppLE은 서로 다른 변수
- 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않는다.
  - 키릴 문자, 상형 문자도 사용할 수 있으나 영어를 사용하는 것이 국제적인 관습
- 예약어 목록에 있는 단어는 변수명으로 사용할 수 없다.
  - 자바스크립트 내부에서 이미 사용 중이기 때문

```javascript
// 예약어 예시 : let, class, return, function
// 문법 에러 발생 예시
let let = 5; // 'let'을 변수명으로 사용할 수 없으므로 에러
let return = 5; // 'return'을 변수명으로 사용할 수 없으므로 에러
```

- `use strict` 없이 할당하기
  - 예전에는 let 없이도 단순하게 값을 할당해 변수를 생성하는 것이 가능했다.
  - `use strict`를 쓰지 않으면 과거 스크립트와의 호환성을 유지할 수 있기 때문에 이 방식을 사용할 수 있다.
  - 하지만 엄격 모드에서 에러를 발생시키기 때문에 나쁜 관습이다.

```javascript
// "use strict"가 없을 때 예제
num = 5; // 변수 'num'이 정의되어있지 않아도 단순 할당만으로 변수가 생성된다.

alert(num); // 5
```

## 상수

- 변화하지 않는 변수를 선언할 땐 `let`대신 `const` 사용

```javascript
const myBirthday = '1997.05.28';
```

- `const`로 선언한 변수를 '상수(constant)' 라고 부른다.
  - 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에러가 발생한다.
- 변숫값이 절대 변경되지 않을 것이라 확신하면, 값이 변경되는 것을 방지하면서 상수라는 것을 알리기위해 `const`를 사용해 변수를 선언하자.

## 대문자 상수

- 기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습이다.
  - 이런 상수는 대문자와 밑줄로 구성된 이름으로 명명한다.

```javascript
// 웹에서 사용하는 색상 표기법인 16진수 컬러 코드에 대한 상수 예시
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

- 대문자로 상수를 만들어 사용하면 장점이 있다.
  - `COLOR_ORANGE` 는 `"#FF7F00"` 보다 기억하기가 훨씬 쉽다.
  - `COLOR_ORANGE`를 사용하면 `"#FF7F00"`를 사용하는 것보다 오타를 낼 확률이 낮다.
  - `COLOR_ORANGE`가 `"#FF7F00"`보다 훨씬 유의미하므로, 코드 가독성이 증가한다.
- 언제 일반적인 방식으로 상수를 명명하고, 언제 대문자를 사용해서 명명해야 할까?
  - '상수'는 변수의 값이 절대 변하지 않음을 의미한다.
    - 그 중에는 빨간색을 나타내는 16진수 값처럼 코드가 샐행되기 전에 이미 그 값을 알고 있는 상수도 있고,
    - 런타임 과정에서 계산되지만 최초 할당 이후 값이 변하지 않는 상수도 있다.

```javascript
// 예시
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```

- `pasgeLoadTime`의 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 지었다.
  - 하지만 최초 할당 이후에 변경되지 않으므로 여전히 상수이다.
- 대문자 상수는 '하드 코딩한' 값의 별칭을 만들 때 사용하면 된다.

## 바람직한 변수명

- 변수명은 간결하고, 명확해야한다.
  - 변수가 담고있는 것이 무엇인지 잘 설명할 수 있어야 한다.
- 변수의 이름을 짓는 것은 프로그래밍에서 가장 중요하고 복잡한 기술 중 하나이다.
  - 변수명만봐도 초보자가 코드를 작성했는지, 노련한 개발자가 작성했는지 알 수 있다.
- 실제 프로젝트에선 처음부터 완전히 독립적인 코드를 작성하기보다 기존 코드의 틀을 변경하고 확장하는데 대부분의 시간을 보낸다.
  - 작성했던 코드를 얼마 후에 다시 보았을 때, 정보에 알맞은 이름이 적혀있다면 정보를 더 쉽게 찾을 수 있다.
- 변수 명명 시 참고하기 좋은 규칙
  - `userName`이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용한다.
  - 무엇을 하고 있는지 명확히 알고 있지 않는 경우 외에는 줄임말이나 `a`, `b`, `c`와 같은 짧은 이름은 피한다.
  - 최대한 서술적이고 간결하게 명명한다.
    - `data`와 `value`는 나쁜 이름의 예시이다.  
      아무것도 설명해주지 않기 때문.  
      코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때만 이런 이름을 사용한다.
  - 자신만의 규칙이나 소속된 팀의 규칙을 따른다.
    - 만약 사이트 방문객을 'user'라고 부르기로 했다면?
      - 이와 관련된 변수를 `currentVisitor`나 `newManInTown`이 아닌 `currentUser`나 `newUser`라는 이름으로 지어야 한다.

---

- 재사용된 변수는 과거에 붙여진 스티커를 떼지 않은 채 물건만 바뀐 상자와 같다.
  - 변수를 재사용하면 변수 선언에 쏟는 노력을 덜 수 있지만, 디버깅에 열 배 더 많은 시간을 쏟아야 한다.
- 변수를 추가하는 것은 악습이 아닌 좋은 습관이다.
  - 모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘해준다.  
    변수를 추가한다고 해서 성능 이슈가 생기지 않는다.  
    값이 다른 경우, 변수를 다르게 선언해 주면 코드 최적화에 도움이 될 수 있다.

---

# 자료형

- 자바스크립트에서 값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속한다.
- 자바스크립트에는 여덟 가지 기본 자료형이 있다.
- 자바스크립트의 변수는 자료형에 관계없이 모든 데이터를 다룰 수 있다.
  - 따라서 변수는 어떤 순간에 문자열 일수도, 다른 순간엔 숫자가 될 수도 있다.

```javascript
let message = "hello";
message = 123456;
```

- 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어
  - 동적 타입(dynamically typed) 언어라고 부른다.

## 숫자형

```javascript
let n = 123;
n = 12.345;
```

- 숫자형(number type)은 정수 및 부동소수점 숫자를 나타낸다.
- 숫자형과 관련된 연산은 곱셈(*), 나눗셈(/), 덧셈(+), 뺄셈(-) 등이 대표적
- 숫자형엔 일반적인 숫자 외에 `Infinity`, `-Infinity`, `NaN`같은 '특수 숫자 값(special numeric value)'이 포함된다.
  - `Infinity`는 어떤 숫자보다 큰 특수 값, 무한대를 나타낸다.
    - 어느 숫자든 0으로 나누면 무한대를 얻을 수 있다.  
      `alert(1 / 0); // 무한대`
    - `Infinity`를 직접 참조할 수도 있다.  
      `alert(Infinity); // 무한대`
  - `NaN`은 계산 중에 에러가 발생했다는 것을 나타내주는 값.
    - 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중 에러가 발생하는데, 이때 `NaN`이 반환된다.  
      `alert("숫자가 아님" / 2); // NaN, 문자열을 숫자로 나누면 오류가 발생`
    - `NaN`은 어지간해선 바뀌지 않는다. 어떤 추가 연산을 해도 결국 `NaN`이 반환된다.  
      `alert("숫자가 아님" / 2 + 5); // NaN`
    - 연산 과정 어디서에선가 `NaN`이 반환되었다면, 이것은 모든 결과에 영향을 미친다.

## BigInt

- 내부 표현 방식 때문에 자바스크립트에서는 (2<sup>53</sup>-1) (9007199254740991) 보다 큰 값 혹은 -(2<sup>53</sup>-1) 보다 작은 정수는 '숫자형'을 통해 나타낼 수 없다.
- 대부분의 상황에서 이런 제약사항은 문제가 되지 않는다.
  - 하지만 암호 관련 작업처럼 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때는 큰 숫자가 필요하다.
- `BigInt` 형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있다.
  - 정수 리티럴 끝에 `n`을 붙이면 만들 수 있다.

```javascript
// 끝에 'n'이 붙으면 BigInt형 자료
const bigInt = 1234567890123456789012345678901234567890n;
```

## 문자형

- 자바스크립트에선 문자열(String)을 따옴표로 묶는다.

```javascript
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```

- 따옴표는 세 종류가 있다.
  1. 큰 따옴표 : `"Hello"`
  2. 작은 따옴표 : `'Hello'`
  3. 역 따옴표(백틱, backtick) : ```Hello` ``
- 큰 따옴표와 작은 따옴표는 기본적인 따옴표
  - 자바스크립트는 이 둘에 차이를 두지 않는다.
- 역 따옴표로 변수나 표현식을 감싼 후 `${...}`안에 넣어주면 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있다.

```javascript
let name = "John";

// 변수를 문자열 중간에 삽입
alert(`Hello, ${name}!`); // Hello, John!

// 표현식을 문자열 중간에 삽입
alert(`the result is ${1 + 2}`); // the result is 3
```

- `${...}`안에는 `name`같은 변수나 `1 + 2`같은 수학 관련 표현식을 넣을 수 있다.
  - 더 복잡한 표현식도 넣을 수 있다.
- 큰 따옴표나 작은 따옴표를 사용하면 중간에 표현식을 넣을 수 없다.

---

- 글자형은 없다.
  - 일부 언어는 글자 하나를 저장할 때 쓰이는 자료형을 따로 지원한다.
    - C 언어와 Java의 `char`가 대표적인 예
  - 자바스크립트는 글자형을 지원하지 않는다.
    - `문자형`만 있을 뿐, 글자 하나 혹은 여러 개가 들어갈 수 있다.

---

## 불린형

- 불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형이다.
  - 긍정(yes)이나 부정(no)을 나타내는 값을 저장할 때 사용한다.

```javascript
// 예시
let nameFieldChecked = true // 네, name field가 확인됨(checked).
let ageFieldChecked = false // 아니오, age field를 확인하지 않았다(not checked).
```

- 불린값은 비교 결과를 저장할 때도 사용된다.

```javascript
let isGreater = 4 > 1;
alert(isGreater); // true
```

## 'null' 값

- `'null'`값은 자료형 중 어느 자료형에도 속하지 않는 값
  - `'null'` 값은 오로지 `'null'`값만 포함하는 별도의 자료형을 만든다.

```javascript
let age = null;
```

- 자바스크립트의 `'null'`은 자바스크립트 이외의 언어 `'null'`과 성격이 다르다.
  - 다른 언어에선 `'null'`을 '존재하지 않는 객체에 대한 참조'나 '널 포인터'를 나타낼 때 사용한다.
  - 하지만 자바스크립트에선 `'null'`을 '존재하지 않는 값', '비어 있는 값', '알 수 없는 값'을 나타내는 데 사용한다.

```javascript
let age = null; // 나이(age)를 알 수 없거나 그 값이 비어있음을 보여준다.
```

## 'undefined' 값

- `undefined` 값도 `null` 값처럼 자신만의 자료형을 형성한다.
  - `undefined`는 '값이 할당되지 않은 상태'를 나타낼 때 사용한다.
  - 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당된다.

```javascript
let age;
alert(age); // 'undefined' 가 출력됨
```

- 개발자가 변수에 `undefined`을 명시적으로 할당하는 것도 가능하긴 하다.

```javascript
let age  = 100;

age = undefined;

alert(age); // undefined
```

- 하지만 `undefined`를 직접 할당하는 걸 권장하지 않는다.
  - 변수가 '비어있거나' '알 수 없는' 상태라는 걸 나타내려면 `null`을 사용한다.
  - `undefined` 는 값이 할당되지 않는 변수의 초기값을 위해 예약어로 남기자.

## 객체와 심볼

- 객체(object)형은 특수한 자료형이다.
- 객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다.
  - 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있다.
- 이런 특징 때문에 자바 스크립트에서 객체는 좀 더 특별한 취급을 받는다.
- 심볼(symbol)형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용된다.

## typeof 연산자

- `typeof` 연산자는 인수의 자료형을 반환한다.
  - 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용하다.
- `typeof` 연산자는 두 가지 형태의 문법을 지원한다.
  1. 연산자 : `typeof x`
  2. 함수 : `typeof(x)`
- 괄호가 있든 없든 결과가 동일
- `typeof x`를 호출하면 인수의 자료형을 나타내는 문자열을 반환한다.

```javascript
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigInt"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object" (1)
 
typeof null // "object" (2)

typeof alert // "function" (3)
```

1. `Math`는 수학 연산을 제공하는 내장 객체이므로 `"object"`가 출력된다.
2. `typeof null`의 결과는 `"object"`이다.
   - `null`은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨두었다.
   - 언어 자체의 오류이므로 `null`은 객체가 아니다.
3. `typeof`는 피연산자가 함수면 `"function"`을 반환한다.
   - 그런데 '함수'형은 따로 없다. 함수는 객체형에 속한다.
   - 이런 동작 방식이 형식적으로 잘못되긴 했지만 아주 오래전에 만들어진 규칙이었기 때문에 하위 호환성 유지를 위해 남겨진 상태

# alert, prompt, confirm을 이용한 상호작용

- 브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능

## alert

- `alert` 함수는 실행되면 사용자가 확인 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 된다.

```javascript
// 예시
alert("Hello");
```

- 메시지가 있는 작은 창은 모달 창(modal window)라고 부른다.
  - '모달'이란 단어엔 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미가 내포되어 있다.
  - 사용자는 확인 버튼을 누르기 전까지 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수가 없다.

## prompt

- 브라우저에서 제공하는 `prompt`함수는 두 개의 인수를 받는다.

```javascript
result = prompt(title, [default]);
```

- 함수가 실행되면 텍스트 메시지와 입력 필드, 확인 및 취소 버튼이 있는 모달 창을 띄워준다.
- title
  - 사용자에게 보여줄 문자열
- default
  - 입력 필드의 초기값(선택값)
  - [ ... ]은 이 매개변수가 필수가 아닌 선택값이라는 것을 의미
- 사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있다.
  - 값을 입력하길 원하지 않는 경우는 취소 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 된다.
- `prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환한다.
  - 입력을 취소한 경우는 `null`이 반환된다.

```javascript
int age = prompt('나이를 입력해주세요.', 100);
alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살 입니다.
```

- Internet Explorer 에서는 항상 기본값을 넣어준다.
  - IE 사용자를 비롯한 모든 사용자에게 깔끔한 프롬프트를 보여주려면 두 번째 매개변수를 항상 전달해 줄 것이 권장된다.

```javascript
let test = prompt("Test", '');
```

## 컨펌 대화상자

```javascript
result = confirm(question);
```

- `confirm`함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여준다.
  - 사용자가 확인 버튼을 누르면 true, 그 외의 경우는 false를 반환한다.

```javascript
let isBoss = confirm("당신이 주인인가요?");
alert(isBoss); // 확인 버튼을 눌렀다면 true출력
```

- `alert`, `prompt`, `confirm` 함수들은 모두 모달 창을 띄워준다.
  - 모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단된다.
  - 사용자가 창을 닫기 전까지 나머지 페이지와의 상호 작용이 불가능

# 형 변환

- 함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환된다.
  - 이런 과정을 형 변환(type conversion)이라고 한다.
- `alert`는 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여준다.
  - 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시
- 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이다.

## 문자형으로 변환

- 문자형으로의 형 변환은 문자형의 값이 필요할 때 일어난다.
- `alert`메서드는 매개변수로 문자형을 받기 때문에 `alert(value)`에서 value는 문자형이어야 한다.
  - 만약 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환된다.
- String(value) 함수를 호출해서 전달받은 값을 문자열로 변환 할 수도 있다.

```javascript
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value에 문자열 "true"가 저장됨
alert(typeof value); // string
```

- false는 문자열 "false"로, null은 문자열 "null"로 변환되는 것과 같다.
  - 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어난다.

## 숫자형으로 변환

- 숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.

```javascript
alert("6" / "2"); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행된다.
```

- `Number(value)`함수를 사용하면 주어진 value를 숫자형으로 명시해서 변환할 수 있다.

```javascript
let str = "123";
alert(typeof str); // string

int num = Number(str); // 문자열 "123"이 숫자 123으로 변환

alert(typeof num); // number
```

- 숫자형 값을 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우
  - 명시적 형변환이 필수이다.
- 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면?
  - 결과는 `NaN`이 된다.

```javascript
let age = Number("문자열123");
alert(age); // NaN
```

- 숫자형으로 변환 시 적용되는 규칙

| 전달받은 값    | 형 변환 후                                                   |
| -------------- | ------------------------------------------------------------ |
| undefined      | NaN                                                          |
| null           | 0                                                            |
| true and false | 1과 0                                                        |
| string         | 문자열의 처음과 끝 공백이 제거된다. 공백 제거 후 남아있는 문자열이 없다면 0, 그렇지 않다면 문자열에서 숫자를 읽는다. 변환에 실패하면 NaN이 된다. |

```javascript
alert(Number("   123   ")); // 123
alert(Number("123z"));		// NaN
alert(Number(true));		// 1
alert(Number(false));		// 0
```

- `null`과 `undefined`는 숫자형으로 변환 시 결과가 다른것에 유의
  - `null`은 0
  - `undefined`는 NaN
- 대부분의 수학 연산은 형 변환을 수반한다.

## 불린형으로 변환

- 논리 연산을 수행할 때 발생한다.
- `Boolean(value)`를 호출하면 명시적으로 불리언으로 형 변환을 수행할 수 있다.
- 불린형으로 변환 시 적용되는 규칙
  - 숫자 0, 빈 문자열, null, undefined, NaN과 같이 직관적으로도 "비어있다" 느껴지는 값들은 `false`가 된다.
  - 그 외의 값은 `true`로 변환된다.

```javascript
alert(Boolean(1)); // true
alert(Boolean(0)); // false

alert(Boolean("hello")); // true
alert(Boolean(""));	// false
```

- 주의
  - 문자열 `"0"`은 `true`이다.
  - PHP등의 일부 언어에선 문자열`"0"`은 `false`로 취급하지만 자바스크립트에선 비어 있지 않은 문자열은 언제나 `true`

# 기본 연산자와 수학

## 용어 : '단항', '이항', '피연산자'

- 피연산자
  - 연산자가 연산을 수행하는 대상
  - `5 * 2`에는 왼쪽 피연산자 5와 오른쪽 피연산자 2, 총 두 개의 피연산자가 있다.
  - 피연산자는 '인수(argument)'라는 용어로 불리기도 한다.
- 피연산자를 하나만 받는 연산자는 단항(unary) 연산자라고 부른다.
  - 피연산자의 부호를 뒤집는 단항 마이너스 연산자 `-` 는 단항 연산자의 대표적인 예
- 두 개의 피연산자를 받는 연산자는 이항(binary) 연산자라고 부른다.
  - 마이너스 연산자는 이항 연산자로 쓸 수도 있다. `y - x`
- 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자는 기호는 같지만 수행하는 연산이 다르다.
  - 두 연산을 구분하는 기준은 피연산자의 개수

## 수학

- 자바스크립트에서 지원하는 수학 연산자
  - 덧셈 연산자 `+`
  - 뺄셈 연산자 `-`
  - 곱셈 연산자 `*`
  - 나눗셈 연산자 `/`
  - 나머지 연산자 `%`
  - 거듭제곱 연산자 `**`

## 나머지 연산자 %

- 표현식 `a % b`는 a를 b로 나눈 후 그 나머지(remainder)를 정수로 반환해준다.

```javascript
alert(5 % 2); // 1
alert(8 % 3); // 2
```

## 거듭제곱 연산자 **

- `a ** b`를 평가하면 a를 b번 곱한 값이 반환된다.

```javascript
alert(2 ** 2); // 4
alert(2 ** 3); // 8
alert(2 ** 4); // 16
```

- 정수가 아닌 숫자에도 동작한다. (제곱근 구하기)

```javascript
alert(4 ** (1/2)); // 2 (1/2 거듭제곱은 제곱근)
alert(8 ** (1/3)); // 3 (1/3 거듭제곱은 세제곱근)
```

## 이항 연산자 '+'와 문자열 연결

- 덧셈 연산자 `+`는 숫자를 더한 결과를 반환한다.
  - 그런데 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 연결한다.

```javascript
let s = "my" + "string";
alert(s); // mystring
```

- 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환

```javascript
alert('1' + 2); // "12"
alert(2 + '1'); // "21"
// 복잡한 예시
alert(2 + 2 + '1'); // 41
```

- 연산은 왼쪽에서 오른쪽으로 순차적으로 진행된다.
  - 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 문자와 문자열과의 병합
- `+`는 문자열 연결과 변환이라는 특별한 기능을 제공
  - 다른 산술 연산자가 오직 숫자형의 피연산자만 다르고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적이다.

```javascript
alert(6 - '2'); // 4, '2'를 숫자로 바꾼 후 연산이 진행된다.
alert('6' / '2'); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행된다.
```

## 단항 연산자 +와 숫자형으로의 변환

- `+`는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있다.
- 숫자에 단항 덧셈 연산자를 붙이면 아무런 동작도 하지 않는다.
  - 하지만 피연산자가 숫자가 아닌 경우 숫자형으로의 변환이 일어난다.

```javascript
// 숫자엔 영향 없음
let x = 1;
alert(+x); // 1

let y = -2;
alert(+y); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화한다.
alert(+true); // 1
alert(+""); // 0
```

- 덧셈 연산자는 짧은 문법으로도 `Number(...)`와 동일한 일을 할 수 있게 해준다.
- 문자열을 숫자로 변환해야 하는 경우
  - HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때

```javascript
let apples = "2";
let oranges = "3";
alert(apples + oranges); // 23, 문자열을 연결

// 값을 더해주려면 단항 덧셈 연산자를 사용해서 숫자형으로 변화시키면 된다.
alert(+apples + +oranges); // 5

// `Number(...)`를 사용한 경우
alert(Number(apples) + Number(oranges)); // 5
```

## 연산자 우선순위

- 하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 우선순위에 의해 결정된다.
- `1 + 2 * 2`라는 식에서 곱셈이 높은 우선순위를 가져 먼저 수행된다.
- 괄호는 모든 연산자보다 우선순위가 높기 때문에 연산자 우선순위를 무력화시킨다.
  - `(1 + 2) * 2`에서 괄호로 둘러싼 덧셈 연산자가 먼저 수행된다.
- 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다.

## 할당 연산자

- 무언가에 할당할 때 쓰이는 `=`도 연산자이다.
  - 할당(assignment) 연산자라고 불리는데, 우선순위는 3으로 아주 낮다
  - `x = 2 * 2 + 1`과 같은 표현식에서 계산이 먼저 이루어지고, 그 결과가 x에 할당되는 이유가 바로 이 때문

```javascript
let x = 2 * 2 + 1;
alert(x); // 5
```

## 값을 반환하는 할당 연산자

- `=`는 연산자이기 때문에 흥미로운 함축성을 내포하고 있다.
  - 자바스크립트에서 대부분의 연산자들은 값을 반환한다. + 와 - 뿐만 아니라 = 도 값을 반환.
- `x = value`를 호출하면 value가 x에 쓰여지고, value가 반환된다.

```javascript
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);

alert(a); // 3
alert(c); // 0
```

## 할당 연산자 체이닝

- 할당 연산자는 여러 개를 연결할 수도 있다.

```javascript
let a, b, c;

a = b = c = 2 + 2;

alert(a); // 4
alert(b); // 4
alert(c); // 4
```

- 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행된다.
  - 가장 우측의 `2 + 2`가 평가되고, 그 결과가 좌측의 c, b, a에 순차적으로 할당된다.
  - 되도록이면 체이닝 하는 것보다 가독성을 위해 줄을 나눠 작성하는게 좋다.

```javascript
c = 2 + 2;
b = c;
a = c;
```

## 복합 할당 연산자

- 프로그램을 짜다 보면 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우가 생긴다.

```javascript
let n = 2;
n = n + 5;
n = n * 2;
```

- `+=`와 `*=`연산자를 사용하면 짧은 문법으로 동일한 연산을 수행할 수 있다.

```javascript
let n = 2;
n += 5;
n *= 2;
alert(n) // 14
```

- 복합 할당 연산자는 산술 연산자와 비트 연산자에도 적용할 수 있다.
  - 우선순위는 할당 연산자와 동일하다.

```javascript
let n = 2;
n *= 3 + 5;
alert(n); // 16
```

## 증가/감소 연산자

- 숫자를 하나 늘리거나 줄이는 연산자

```javascript
// 증가 연산자 ++ 는 변수를 1 증가시킴
let counter = 2;
counter++;
alert(counter); // 3

// 감소 연산자 -- 는 변수를 1 감소시킴
let counter = 2;
counter--;
alert(counter); // 1
```

- 증가/감소 연산자는 변수에만 쓸 수 있다.
  - `5++`와 같이 값에 사용하려고 하면 에러 발생
- `++`와 `--`는 변수 앞이나 뒤에 올 수 있다
  - `counter++`와 같이 피연산자 뒤에 올 때는 후위형(postfix form)이라고 부른다.
  - `counter--`와 같이 피연산자 앞에 올 때는 전위형(prefix form)이라고 부른다
- 전위형은 증가/감소 후의 새로운 값을 반환하는 반면, 후위형은 증가/감소 전의 기존 값을 반환한다.

```javascript
let counter = 1;
let a = ++counter;
alert(a); // 2
// ++counter는 counter를 증가시키고 새로운 값 2를 반환한다.
```

```javascript
let counter = 1;
let a = counter++;
alert(a); // 1
//counter++는 counter를 증가시키긴 하지만, 증가 전의 기존값을 반환한다.
```

- 반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없다.

```javascript
let coutner = 0;
counter++;
++counter;
alert(counter); // 2
```

- 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용

```javascript
let counter = 0;
alert(++counter); // 1
```

- 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용

```javascript
let counter = 0;
alert(counter++); // 0
```

---

- 다른 연산자 사이의 증가/감소 연산자
  - `++/--` 연산자를 표현식 중간에 사용하는 것도 가능하다.
  - 이때, 증가/감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이루어진다.

```javascript
let counter = 1;
alert(2 * ++counter); // 4
```

```javascript
let counter = 1;
alert(2 * counter++); // 기존값을 반환하기 때문에 2가 출력된다.
```

- 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어진다.
  - 코드를 읽을 때 눈을 수직으로 빠르게 움직이다 보면 `counter++`같은 것을 놓치기 쉽다.
  - 코드 한 줄엔 특정 동작 하나에 관련된 내용만 작성하는 게 좋다.

```javascript
let counter = 1;
alert(2 * counter);
counter++;
```



## 비트 연산자

- 비트 연산자(bitwise operator)는 인수를 32비트 정수로 변환하여 이진 연산을 수행한다
- 비트 연산 시 쓰이는 연산자 목록
  - 비트 AND (`&`)
  - 비트 OR (`|`)
  - 비트 XOR (`^`)
  - 비트 NOT (`~`)
  - 왼쪽 시프트 (`<<`)
  - 오른쪽 시프트 (`>>`)
  - 부호 없는 오른쪽 시프트 (`>>>`)
- 웹 개발 시엔 2진 표현에서 숫자를 다루는 일이 자주 일어나지 않는다.
  - 암호를 다뤄야 할 땐 비트 연산자가 유용하다.

## 쉼표 연산자

- 쉼표 연산자(comma operator) `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나.
  - 코드를 짧게 쓰려는 의도로 가끔 사용된다.
- 쉼표 연산자`,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다.
  - 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환된다.

```javascript
let a = (1 + 2, 3 + 4);
alert(a); // 7
```

- `1 + 2`는 평가가 되지만 그 결과는 버려진다.
  - `3 + 4`만 평가되어 `a`에 할당된다.
- 쉼표의 우선순위는 매우 낮다.
  - 할당 연산자 `=`보다 더 낮다.
  - 따라서 괄호가 중요한 역할을 한다.
  - 괄호가 없으면 `a = 1 + 2, 3 + 4`에서 +가 먼저 수행되어 `a = 3, 7`이 된다.
    - 할당 연산자 `=`는 쉼표보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지 7은 무시된다.  
      `(a = 1 + 2), 3 + 4`를 연산한 것처럼 된다.
- 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용될까?
  - 여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 사용한다.

```javascript
// 한 줄에서 세 개의 연산이 수행된다.
for (a = 1, b = 3, c = a * b; a < 10; a++) {
    ...
}
```

- 쉼표 연산자를 사용한 트릭은 여러 자바스크립트 프레임워크에서 볼 수 있다.
- 쉼표 연산자는 코드 가독성에 도움이 되지 않는다.
  - 진짜 필요한 경우에만 사용하자.

# 비교 연산자

- 자바스크립트에서 기초 수학 연산
  - 보다 큼/작음 : `a > b`, `a < b`
  - 보다 크거나/작거나 같음 : `a >= b`, `a <= b`
  - 같음(동등) : `a == b`
  - 같지 않음(부등) : `a != b`

## 불린형 반환

- 비교 연산자도 값을 반환한다. 반환 값은 불린형
  - true가 반환되면 '긍정', '참', '사실'을 의미
  - false가 반환되면 '부정', '거짓', '사실이 아님'을 의미

```javascript
alert(2 > 1); // true
alert(2 == 1); // false
alert(2 != 1); // true
```

- 반환된 불린값은 다른 변수에 할당할 수 있다.

```javascript
let result = 5 > 4;
alert(result); // true
```

## 문자열 비교

- 자바스크립트는 '사전' 순으로 문자열을 비교한다.
  - '사전 편집(lexicographical)'순 이라고도 불리기도 한다.
  - 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단
- 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교

```javascript
alert('Z' > 'A'); // true
alert('Glow' > 'Glee'); // true
alert('Bee' > 'Be'); // true
```

- 문자열 비교 시 적용되는 알고리즘
  1. 두 문자열의 첫 글자를 비교한다.
  2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(or작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(or작다고) 결론 내고 비교를 종료
  3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
  4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
  5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 낸다.  
     비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.
- 정확히는 사전순이 아니라 유니코드 순이다.
  - 자바스크립트 내부에서 사용되는 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖는다.
  - 대문자 "A"와 소문자 "a"를 비교했을 때 소문자 "a"가 더 크다.

## 다른 형을 가진 값 간의 비교

- 비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꾼다.

```javascript
alert('2' > 1); // true, 문자열 '2'가 숫자 2로 변환된 후 비교
alert('01' == 1); // true, 문자열 '01'이 숫자 1로 변환된 후 비교
```

- 불린값의 경우 true는 1, false는 0으로 변환된 후 비교

```javascript
alert(true == 1); // true
alert(false == 0); // true
```

- 같이 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있다.
  - 동등 비교(==)시 true를 반환함
  - 논리 평가 시 값 하나는 true, 다른 값 하나는 false를 반환함

```javascript
let a = 0;
alert(Boolean(a)); // false

let b = "0";
alert(Boolean(b)); // true

alert(a == b); // true
```

- 동등 비교 연산자 `==`는 피연산자를 숫자형으로 바꾸지만, Boolean을 사용한 명시적 변환에는 다른 규칙이 적용되기 때문

## 일치 연산자

- 동등 연산자 `==`은 `0`과 `false`를 구분하지 못한다.

```javascript
alert(0 == false); // true
```

- 피연산자가 빈 문자열일 때도 같다.

```javascript
alert('' == false); // true
```

- 이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다.
- 0과 false는 어떻게 구별할까?
  - 일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있다.
  - 일치 연산자는 엄격한(strict) 동등 연산자이다.  
    자료형의 동등 여부까지 검사하기 때문에 피연산자 a와 b의 형이 다를 경우 `a === b`는 `false`를 즉시 반환한다.

```javascript
alert(0 === false); // false, 피연산자의 형이 다르다.
```

- 일치 연산자 `===`가 동등 연산자 `==`의 엄격한 형태인 것처럼 "불일치" 연산자 `!==`는 부등 연산자 `!=`의 엄격한 형태이다.
- 일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다.

## null이나 undefined와 비교하기

- `null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다.

### 일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교

- 두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환된다.

```javascript
alert(null === undefined); // false
```

### 동등 연산자 `==`을 사용하여 `null`과 `undefined`를 비교

- 특별한 규칙이 적용돼 `true`가 반환된다.
  - 동등 연산자는 `null`과 `undefined`를 '각별한 커플'처럼 취급한다.
  - 두 값은 자기들끼리는 잘 어울리지만, 다른 값들과는 잘 어울리지 못한다.

```javascript
alert(null == undefined); // true
```

### 산술 연산자나 기타 비교 연산자 `<  >  <=  >=`를 사용하여 `null`과 `undefined`를 비교

- `null`과 `undefined`는 숫자형으로 변환된다.
  - `null`은 0, `undefined`는 NaN 으로 변한다.

#### null VS 0

```javascript
alert(null > 0); // (1)false
alert(null == 0); // (2)false
alert(null >= 0); // (3)true
```

- 논리에 맞지 않다.
  - (3)에서 `null`은 0보다 크거나 같다고 했기 때문에 (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환한다.
- 이는 동등 연산자 `==`와 비교 연산자 `<  >  <=  >=`의 동작 방식이 다르기 때문이다.
  - (1)에서 null > 0이 거짓을, (3)에서 null > 0이 참을 반환하는 이유는 null이 숫자형으로 변환돼 0이 되기 때문이다.
  - 동등 연산자 `==`는 피연산자가 undefined나 null일 때 형 변환을 하지 않는다.
    - undefined와 null을 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환

#### 비교 불가능한 undefined

- `undefined`를 다른 값과 비교해서는 안 된다.

```javascript
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
```

- 항상 false를 반환하고 있다.
- 이유
  - (1)과 (2)에선 `undefined`가 `NaN`으로 변환(숫자형으로 변환)되는데, `NaN`이 피연산자인 경우 비교 연산자는 항상 false를 반환한다.
  - `undefined`는 'null'이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 `false`를 반환한다.

# 조건부 연산자 if와 ?

- 조건에 따라 다른 행동을 취해야 할 때가 있다.
  - 이럴 땐, `if`문과 '물음표' 연산자라고도 불리는 조건부 연산자 `?`를 사용하면 된다.

## if문

- `if(...)`문은 괄호 안에 들어가는 조건을 평가한다.
  - 결과가 `true`이면 코드 블록이 실행된다.

```javascript
let year = prompt("ESMAScript-2015 명세는 몇 년도에 출판되었을까요?", '');
if (year == 2015) alert('정답!');
```

- 조건이 `true`일 때 복수의 문을 실행하고 싶다면?
  - 중괄호로 코드 블록을 감싸야 한다.

```javascript
if (year == 2015) {
    alert("정답!");
    alert("똑똑합네요.");
}
```

- `if`문을 쓸 때는 조건이 참일 경우 실행되는 구문이 단 한줄이라도 중괄호`{ }`를 사용해 코드를 블록으로 감싸는 것이 가독성이 증가한다.

## 불린형으로의 변환

- `if (...)`문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환한다.
- 형 변환 규칙
  - 숫자 0, 빈 문자열 `""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 false가 된다.
    - 이런 값들은 falsy(거짓 같은) 값이라고 부른다.
  - 이 외의 값은 불린형으로 변환시 `true`가 되므로 truthy(참 같은) 값이라고 부른다.

```javascript
// 절대 실행되지 않는 코드블록
if (0) { // 0은 falsy
    ...
}

// 항상 실행되는 코드블록
if (1) { // 1은 truthy
    ...
}
```

- 평가를 통해 확정된 불린값을 `if`문에 전달할 수도 있다.

```javascript
let cond = (year == 2015); // 동등 비교를 통해 true/false 여부를 결정
if (cond) {
    ...
}
```

## else 절

- `if`문엔 `else`절을 붙일 수 있다.
  - `else` 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행

```javascript
let year = prompt("ESMAScript-2015 명세는 몇 년도에 출판되었을까요?", '');
if (year == 2015) {
    alert('정답!');
} else {
    alert("오답!"); // 2015 이외의 값을 입력한 경우
}
```

## else if 로 복수 조건 처리하기

- 유사하지만 약간씩 차이가 있는 조건 여러 개를 처리해야 할 때

```javascript
let year = prompt("ESMAScript-2015 명세는 몇 년도에 출판되었을까요?", '');
if (year < 2015) {
    alert('숫자를 좀 더 올려보세요.');
} else if (year > 2015) {
    alert('숫자를 좀 더 내려보세요.');
} else {
    alert("정답!");
}
```

- 마지막에 붙는 else는 필수가 아닌 선택사항

## 조건부 연산자 '?'

- 조건에 따라 다른 값을 변수에 할당해줘야 할 때

```javascript
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');

if (age > 18) {
    accessAllowed = true;
} else {
    accessAllowed = false;
}

alert(accessAllowed);
```

- 조건부(conditional) 연산자를 사용하면 더 짧고 간결하게 변형할 수 있다.
- 피연산자가 세 개이기 때문에 조건부 연산자를 삼항(ternary) 연산자라고 부르기도 한다.
  - 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일하다.

```javascript
// 문법
let result = condition ? value1 : value2;
```

- 평가 대상인 condition이 truthy라면 value1이, 그렇지 않으면 value2가 반환된다.

```javascript
// 예시
let accessAllowed = (age > 18) ? true : false;
```

- `age > 18` 주위의 괄호는 생략 가능하다.
- 물음표 연산자는 우선순위가 낮으므로 비교 연산자 `>`가 먼저 실행되고 난 뒤에 실행된다.
- 비교 연산자 자체가 true나 false를 반환하기 때문에 위 예시는 물음표 연산자를 사용하지 않아도 된다.

```javascript
let accessAllowed = age > 18;
```

## 다중 '?'

- 물음표 연산자 `?`를 여러 개 연결하면 복수의 조건을 처리할 수 있다.

```javascript
let age = prompt('나이를 입력해주세요.', 18);

let message = (age > 3) ? '아가야 안녕?' :
	(age < 18) ? '안녕?' :
	(age < 100) ? '환영합니다!' :
	'나이가 아주 많으시거나, 나이가 아닌 값을 입력하셨군요.';

alert(message);
```

## 부적절한 '?'

- 물음표 `?`를 `if` 대용으로 쓰는 경우

```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답!') : alert('오답!');
```

- 개발자 입장에선 `if`문을 사용할 때 보다 코드 길이가 짧아진다는 점 때문에 매력적일 순 있다.
  - 하지만 가독성이 떨어지기때문에 이런 식으로 사용하는 것은 좋지 않다.

```javascript
// if를 사용한 코드
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답!');
} else {
  alert('오답!');
}
```

- 코드를 읽을 때 눈은 수직으로 움직이기 때문에 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드블록이 더 읽기 쉽다.
- 물음표 연산자는 조건에 따라 반환 값을 달리 하려는 목적으로 만들어졌다.
  - 이런 목적에 부합하는 곳에 물음표를 사용하자.
  - 여러 분기를 만들어 처리할 때는 `if`를 사용하자.

# 논리 연산자

- 논리 연산자는 피연산자로 불린형뿐만 아니라 모든 타입의 값을 받을 수 있다.
  - 연산 결과 역시 모든 타입이 될 수 있다.

## || (OR)

- 두 개의 수직선 기호로 만들 수 있다.

```javascript
result = a || b;
```

- 전통적인 프로그래밍에서 OR 연산자는 불린값을 조작하는 데 쓰인다.
  - 인수 중 하나라도 true이면 true를 반환하고, 그렇지 않으면 false를 반환
- OR 연산자는 이항 연산자 이므로 네 가지 조합이 가능하다.

```javascript
alert(true || true); // true
alert(false || true); // true
alert(true || false); // true
alert(false || false); // false
```

- 피연산자가 모두 `false`인 경우를 제외하고 연산 결과는 항상 `true`이다.
- 피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환된다.

```javascript
if (1 || ) { // if (ture || false) 와 동일하게 동작
    alert('truthy');
}
```

- OR 연산자 `||`은 `if`문에서 자주 사용된다.
  - 주어진 조건 중 하나라도 참 인지를 테스트하는 용도

```javascript
let hour = 9;

if (hour < 10 || hour > 18) {
    alert('영업 시간이 아닙니다.');
}
```

- `if`문 안에 여러 가지 조건을 넣을 수 있다.

```javascript
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
    alert('영업 시간이 아닙니다.') // 주말이기 때문
}
```

## 첫 번째 truthy를 찾는 OR 연산자 '||'

- 자바스크립트에서 제공하는 논리 연산자 OR의 추가기능

```javascript
// OR 연산자와 피연산자가 여러 개인 경우
result = value1 || value2 || value3;
/*
1.	가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
2.	각 피연산자를 불린형으로 변환한다.
	변환 후 그 값이 true이면 연산을 멈추고 해당 피연산자의 변환 전 원래 값을 반환한다.
3.	피연산자 모두를 평가한 경우(모든 피연산자가 false로 평가되는 경우)엔 마지막 피연산자를 반환한다.
*/
```

- 핵심은 반환 값이 형 변환을 하지 않은 원래 값이라는 것

```javascript
alert( 1 || 0 ); // 1

alert( null || 1 ); // 1
alert( null || 0 || 1 ); // 1

alert( undefined || null || 0 ); // 0, 마지막 값 반환
```

- OR 연산자의 추가 기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있다.

### 1. 변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기

- `||`을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다.

```javascript
// firstName, lastName, nickName이란 변수를 옵션 값이라고 가정
// 변수 모두에 값이 없는 경우엔 익명을 보여준다.
let firstName = "";
let lastName = "";
let nickName = "바이올렛";

alert( firstName || lastName || nickName || "익명"); // 바이올렛
// 모든 변수가 falsy이면 "익명"이 출력된다.
```

### 2. 단락 평가

- OR 연산자가 제공하는 또 다른 기능은 단락평가이다.
  - 왼쪽부터 시작해 오른쪽으로 평가를 진행하는데, truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다.
- 단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 부수적인 효과(side effect)를 가지는 표현식 일 때 명확히 볼 수 있다.

```javascript
// 두 번째 메시지만 출력된다.
true || alert("not printed"); // true를 만나자마자 평가를 멈추기 때문에 alert가 실행되지 않는다.
false || alert("printed");
```

- 단락 평가는 조건이 truthy일 때만 명령어를 실행하고자 할 때 자주 쓰인다.

##  && (AND)

- 두 개의 앰퍼샌드를 연달아 쓰면 AND 연산자 `&&`를 만들 수 있다.

```javascript
result = a && b;
```

- 전통적인 프로그래밍에서 AND 연산자는 두 피연산자가 모두 참일 때 `true`를 반환한다.
  - 그 외의 경우 `false`반환

```javascript
alert(true && true);   // true
alert(false && true);  // false
alert(true && false);  // false
alert(false && false); // false
```

- `if`문과 AND 연산자를 함께 활용한 예시

```javascript
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( '현재 시각은 12시 30분입니다.' );
}
```

- OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없다.

```javascript
if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 된다.
  alert("if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다.");
}
```

## 첫 번째 falsy를 찾는 AND 연산자 '&&'

- AND 연산자와 피연산자가 여러 개인 경우

```javascript
result = value1 && value2 && value3;
/*
1.	가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
2.	각 피연산자는 불린형으로 변환된다. 변환 후 값이 false이면 평가를 멈추고 해당 피연산자의 변환 전 원래 값을 반환한다.
3.	피연산자 모두가 평가되는 경우(모든 피연산자가 true로 평가되는 경우)엔 마지막 피연산자가 반환된다.
*/
```

- OR 연산자의 알고리즘과 유사하다.
  - 차이점은 AND 연산자가 첫 번째 falsy를 반환하는 반면, OR은 첫 번째 truthy를 반환한다는 것

```javascript
// 예시
// 첫 번째 피연산자가 truthy이면, AND는 두 번째 피연산자를 반환
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자가 falsy이면, AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```

- AND 연산자도 피연산자 여러 개를 연속해서 전달할 수 있다.

```javascript
alert( 1 && 2 && null && 3 ); // null
```

```javascript
// 피연산자가 모두 truthy이기 때문에 마지막 피연산자가 반환된다.
alert( 1 && 2 && 3 ); // 3
```

---

- `&&`의 우선순위가 `||`보다 높다.
  - AND 연산자의 우선순위는 OR 연산자보다 높다.
  - `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작
- `if`를 짧게 줄이는 용도로 `||`이나 `&&`로 대체하면 안 된다.

```javascript
let x = 1;

(x > 0) && alert( '0보다 큽니다.' );
```

- `&&`의 오른쪽 피연산자는 평가가 `&&` 우측까지 진행되어야 실행된다.
  - 즉, (X > 0)이 참인 경우에만 실행된다.

```javascript
// if 문을 써서 바꾼 경우
let x = 1;

if (x > 0) alert( '0보다 큽니다.' );
```

- `if`문을 사용한 코드가 무엇을 구현하고자 하는지 더 명백히 드러내고, 가독성도 좋다.
  - AND 연산자는 연산자 목적에 맞게 사용하자.

## ! (NOT)

- 논리 연산자 NOT은 느낌표 `!`를 써서 만들 수 있다.

```javascript
result = !value;
```

- NOT 연산자는 인수 하나만 받고, 연산을 수행한다.
  1. 피연산자를 불린형으로 변환한다.
  2. 1에서 변환된 값의 역을 반환한다.

```javascript
// 예시
alert(!true); // false
alert(!0); // true
```

- NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있다.

```javascript
alert(!!"non-empty string"); // true
alert(!!null); // false
```

- 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과

```javascript
alert(Boolean("non-empty string")); // true
alert(Boolean(null)); // false
```

- `NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||`보다 먼저 실행된다.

# null 병합 연산자 '??'

- null 병합 연산자 `??`를 사용하면 여러 피연산자 중 그 값이 `확정되어있는` 변수를 짧은 문법으로도 찾을 수 있다.
- 상황에 따른 `a ?? b` 평가 결과
  - `a`가 `null`이나 `undefined`가 아니면 `a`
  - `a`가 `null`이나 `undefined`이면 `b`

```javascript
// ??를 사용하지 않고 만든 x = a ?? b와 동일하게 동작하는 코드
x = (a !== null && a !== undefined) ? a : b; // 길이가 길다.
```

```javascript
// firstName, lastName, nickName이란 변수가 모두 옵션 값이라고 생각하고
// 실제 값이 들어있는 변수를 찾고 그 값을 보여주는 예제 (모든 변수에 값이 없다면 익명 출력)
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명"); // 바이올렛
```

## `??` 와 `||`의 차이

- `||`는 첫 번째 truthy 값을 반환한다.
- `??`는 값이 정의되어있는 첫 번째 값을 반환한다.
- `null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점이 매우 중요한 역할을 한다.

```javascript
height = height ?? 100; // height에 값을 정의하지 않은 상태라면 100이 할당된다.
```

- height에 0이 할당된 상태라면?
  - 값이 바뀌지 않고 그대로 남아있게 된다.

```javascript
let height = 0;

alert(height || 100); // 100, 0을 falsy한 값으로 취급했기때문에 null이나 undefined를 할당한 것과 동일하게 처리
alert(height ?? 100); // 0, height가 정확히 null이나 undefined일때만 height에 100을 할당한다.
```

## 연산자 우선순위

- `??`의 연산자 우선순위는 `7`로 꽤 낮다.
  - 대부분의 연산자보다 우선순위가 낮고, `=`와 `?`보다는 조금 높다.
  - 그러므로 복잡한 표현식 안에서 `??`를 사용할 땐 괄호를 추가해주는 게 좋다.

```javascript
let height = null;
let width = null;

// 괄호추가
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

- 괄호를 생략하면 `*`가 먼저 실행된다.

```javascript
let area = height ?? (100 * width) ?? 50;
```

- `??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있다.
  - 안전성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하는 것이 금지되어 있다.

```javascript
// 문법 에러가 발생하는 예시
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

- 에러를 피하려면 괄호를 사용해야 한다.

```javascript
let x = (1 && 2) ?? 3;
alert(x); // 2
```

# while과 for 반복문

## while 반복문

```javascript
while (condition) {
  // 코드
  // 반복문 본문(body)
}
```

- condition(조건)이 truthy이면 반복문 본문의 코드가 실행된다.

```javascript
let i = 0;
while (i < 3) { // 0, 1, 2가 출력
  alert(i);
  i++;
}
```

- 반복문 본문이 한 번 실행되는 것을 반복(iteration, 이터레이션)이라 부른다.
  - 위의 예시는 반복문의 세 번의 이터레이션을 만든다.
- `i++`가 없다면 이론적으론 반복문이 영원히 반복되지만 브라우저는 무한 반복을 멈추게 해 주는 실질적인 수단을 제공한다.
  - 서버 사이드 자바스크립트도 이런 수단을 제공해 주므로 무한 반복되는 프로세스를 죽일 수 있다.
- 반복문 조건엔 비교뿐만 아니라 모든 종류의 표현식, 변수가 올 수 있다.
  - 조건은 while에 의해 평가되고, 평가 후엔 불린값으로 변경된다.

```javascript
let i = 3;
while (i) { // i가 0이 되면 조건이 falsy가 되므로 반복문이 멈춤
  alert(i);
  i--;
}
```

- 반복문 본문이 한 줄짜리 문이라면 대괄호 `{...}`를 생략할 수 있다.

## do..while 반복문

- `do..while` 문법을 사용하면 `condition`을 반복문 본문 아래로 옮길 수 있다.

```javascript
do {
  // 반복문 본문
} while (condition);
```

- 본문이 먼저 실행되고, 조건을 확인한 후 조건이 truthy인 동안엔 본문이 계속 실행된다.

```javascript
// 예제
let i = 0;
do {
  alert(i);
  i++;
} while (i < 3); // 0, 1, 2가 출력
```

- `do..while` 문법은 조건이 truthy 인지 아닌지에 상관없이, 본문을 최소한 한번이라도 실행하고 싶을 때만 사용해야 한다.
  - 대다수의 상황에선 `do..while`보다 `while(...) {...}`이 적합하다.

## for 반복문

- `for`반복문은 `while` 반복문보다는 복잡하지만 가장 많이 쓰이는 반복문이다.

```javascript
// 문법
for (begin; condition; step) {
  // 반복문 본문
}
//--------------------------------------------
for (let i = 0; i < 3; i++) { // 0, 1, 2가 출력
  alert(i);
}
```

- 구성요소
  - begin : 반복문에 진입할 때 단 한 번 실행된다.
  - condition : 반복마다 해당 조건이 확인된다. false이면 반복문을 멈춘다.
  - body : condition이 truthy일 동안 계속해서 실행된다.
  - step : 각 반복의 body가 실행된 이후에 실행된다.
- 인라인 변수
  - 카운터 변수 i를 반복문 안에 선언하는 이러한 방식을 인라인 변수 선언이라고 부른다.
  - 이렇게 선언한 변수는 반복문 안에서만 접근할 수 있다.
  - 인라인 변수 선언 대신, 정의되어 있는 변수를 사용할 수도 있다.

```javascript
// 인라인 변수 사용
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // Error: i is not defined

// 정의되어 있는 변수 사용
let i = 0;

for (i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}

alert(i); // 3
```

### 구성 요소 생략하기

- `for`문의 구성 요소를 생략하는 것도 가능하다.
  - 반복문이 시작될 때 아무것도 할 필요가 없으면 `begin`을 생략하는 것이 가능

```javascript
let i = 0;

for (; i < 3; i++) { // 'begin'이 필요하지 않아 생략
  alert(i); // 0, 1, 2
}
```

```javascript
// step 역시 생략할 수 있다.
let i = 0;

for (; i < 3;) {
  alert(i++);
}
// while(i < 3) 과 동일해진다.
```

- 모든 구성 요소를 생략할 수도 있는데, 무한 반복문이 만들어진다.

```javascript
for (;;) {
  // 본문
}
```

## 반복문 빠져나오기

- 대개는 반복문의 조건이 falsy가 되면 반복문이 종료된다.
  - 특별한 지시자인 `break`를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있다.

```javascript
// 아무런 값도 입력하지 않으면 반복문을 종료하는 예제
let sum = 0;

while (true) {

  let value = +prompt("숫자를 입력하세요.", '');

  if (!value) break;

  sum += value;

}
alert( '합계: ' + sum );
```

- 사용자가 아무것도 입력하지 않거나 `Cancel` 버튼을 눌렀을 때 break된다.
  - 반복문이 즉시 중단되고 제어 흐름이 반복문 아래 첫 번째 줄로 이동한다.
- 반복문의 시작 지점이나 끝 지점에서 조건을 확인하는 것이 아니라 본문 여러 곳에서 조건을 확인해야 하는 경우
  - 무한 반복문 + break 조합을 사용하면 좋다.

## 다음 반복으로 넘어가기

- `continue` 지시자는 `break`의 가벼운 버전이다.
  - `continue` 는 전체 반복문을 멈추지 않고 현재 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 한다.(조건을 통과할 때)
- `continue`는 현재 반복을 종료시키고 다음 반복으로 넘어가고 싶을 때 사용할 수 있다.

```javascript
// continue를 사용해 홀수만 출력하는 예시
for (let i = 0; i < 10; i++) {

  // 조건이 참이라면 남아있는 본문은 실행되지 않는다.
  if (i % 2 == 0) continue;

  alert(i); // 1, 3, 5, 7, 9가 차례대로 출력됨
}
```

- `continue`는 중첩을 줄이는 데 도움을 준다.

```javascript
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert(i);
  }

}
```

- 기술적인 관점에서 봤을 때, 이 위쪽 예시와 동일한데 `continue`를 사용하는 대신 코드를 `if`블록으로 감싼 점만 다르다.
  - 이렇게 작성하면 부작용으로 중첩 레벨이 하나 더 늘어난다.
  - `if`안의 코드가 길어진다면 전체 가독성이 떨어질 수 있다.
- `?` 오른쪽엔 `break`나 `continue`가 올 수 없다.
  - 표현식이 아닌 문법 구조는 삼항 연산자 `?`에 사용할 수 없다.
  - 특히 `break`나 `continue`같은 지시자는 삼항 연산자에 사용하면 안 된다.

```javascript
if (i > 5) {
  alert(i);
} else {
  continue;
}
// 물음표를 사용해 아래코드처럼 바꾸려는 시도를 할 수 있다.
(i > 5) ? alert(i) : continue; // 여기에 continue를 사용하면 안 됨
```

- 문법 에러를 발생시킨다.
  - 이는 물음표 연산자 `?`를 `if`문 대용으로 쓰지 말아야 하는 이유 중 하나이다.

## break/continue 레이블

- 여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우가 종종 생기곤 한다.

```javascript
// i와 j를 반복하며 (0, 0) 부터 (2, 2)까지를 구성하는 좌표 (i, j)를 입력하게 해주는 예시
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면?
  }
}

alert('완료!');
```

- 사용자가 취소 버튼을 눌렀을 때 반복문을 중단시킬 방법이 필요하다.
- input 아래에 평범한 `break` 지시자를 사용하면 안쪽에 있는 반복문만 빠져나올 수 있다.
  - 반복문 두 개를 모두 빠져나와야 하기 때문
  - 이럴 때 레이블을 사용할 수 있다.
- 레이블(label)은 반복문 앞에 콜론과 함께 쓰이는 식별자이다.

```javascript
labelName: for (...) {
  ...
}
```

- 반복문 안에서 `break <labelName>`문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있다.

```javascript
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나온다.
    if (!input) break outer; // outer라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해준다.

    // 입력받은 값을 가지고 무언가를 함
  }
}
alert('완료!');
```

- 레이블을 별도의 줄에 써주는 것도 가능하다.

```javascript
outer:
for (let i = 0; i < 3; i++) { ... }
```

- `continue` 지시자를 레이블과 함께 사용하는 것도 가능하다.
  - 두 가지를 같이 사용하면 레이블이 붙은 반복문의 다음 이터레이션이 실행된다.
- 레이블을 사용한다고 해서 원하는 곳으로 마음대로 점프할 수 있는 것은 아니다.
  - `break`와 `continue`는 반복문 안에서만 사용할 수 있고, 레이블은 반드시 `break`나 `continue` 지시자 위에 있어야 한다.

```javascript
break label; // 아래 for 문으로 점프할 수 없다.

label: for (...)
```

# switch문

- 복수의 `if` 조건문은 `switch`문으로 바꿀 수 있다.

## 문법

- `switch`문은 하나 이상의 `case` 문으로 구성된다.
  - 대개 `default`문도 있지만, 필수는 아니다.

```javascript
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
```

- 변수 `x`의 값과 첫 번째 `case`문의 값 `value1`를 일치 비교한 후, 두 번째 `case`문의 값 `value2`와 비교한다.
  - 이런 과정이 계속 이어진다.
- `case` 문에서 변수 `x`의 값과 일치하는 값을 찾으면 해당 `case`문의 아래 코드가 실행된다.
  - 이때, `break`문을 만나거나 `switch`문이 끝나면 코드의 실행은 멈춘다.
- 값과 일치하는 `case`문이 없다면, `default`문 아래의 코드가 실행된다(`default`문이 있는 경우).

## 예시

```javascript
let a = 2 + 2;

switch (a) {
  case 3:
    alert( '비교하려는 값보다 작습니다.' );
    break;
  case 4:
    alert( '비교하려는 값과 일치합니다.' ); // 해당 코드가 실행
    break;
  case 5:
    alert( '비교하려는 값보다 큽니다.' );
    break;
  default:
    alert( "어떤 값인지 파악이 되지 않습니다." );
}
```

- `case`문 안에 `break`문이 없으면 조건에 부합하는지 여부를 따지지 않고 이어지는 `case`문을 실행한다.
- `switch/case` 문의 인수엔 어떤 표현식이든 올 수 있다.
  - `switch`문과 `case`문은 모든 형태의 표현식을 인수로 받는다.

```javascript
let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("표현식 +a는 1, 표현식 b+1는 1이므로 이 코드가 실행");
    break;
  default:
    alert("이 코드는 실행되지 않는다.");
}
```

## 여러 개의 "case"문 묶기

- 코드가 같은 `case`문은 한데 묶을 수 있다.
- `case3`과 `case5`에서 실행하려는 코드가 같은 경우에 대한 예시

```javascript
let a = 3;

switch (a) {
  case 4:
    alert('계산이 맞습니다.');
    break;

  case 3: // 두 case문을 묶음
  case 5:
    alert('계산이 틀립니다.');
    alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
    break;

  default:
    alert('계산 결과가 이상하네요.');
}
```

- `case 3`과 `case 5`는 동일한 메시지를 보여준다.
- `break`문이 없는 경우 조건에 상관없이 다음 `case`문이 실행되는 부작용이 발생
  - 위의 예시에서 `break` 문을 만날 때까지 코드는 계속 실행된다.

## 자료형의 중요성

- switch문은 일치 비교로 조건을 확인한다.
  - 비교하려는 값과 `case`문의 값의 형과 값이 같아야 해당 `case`문이 실행된다.

```javascript
let arg = prompt("값을 입력해주세요.");
switch (arg) {
  case '0':
  case '1':
    alert( '0이나 1을 입력하셨습니다.' );
    break;
  case '2':
    alert( '2를 입력하셨습니다.' );
    break;
  case 3:
    alert( '이 코드는 절대 실행되지 않습니다!' );
    break;
  default:
    alert( '알 수 없는 값을 입력하셨습니다.' );
}
```

1. 0이나 1을 입력한 경우 첫 번째 `alert`문이 실행된다.
2. 2를 입력한 경우엔 두 번째 `alert`문이 실행된다.
3. 3을 입력하였더라도 세 번째 `alert`문은 실행되지 않는다.
   - `prompt` 함수는 사용자가 입력 필드에 기재한 값을 문자열로 변환해 변환하기 때문에 숫자 3을 입력하더라도 문자열 '3'을 반환한다.
   - 세 번째 `case`문에선 입력한 값과 숫자형 3을 비교하므로 형 자체가 다르기 때문에 `case 3` 아래의 코드는 절대 실행되지 않는다.
   - 대신 `default`문이 실행된다.

# 함수

- 스크립트를 작성하다 보면 유사한 동작을 하는 코드가 여러 곳에서 필요할 때가 많다.
- 함수는 프로그램을 구성하는 주요 구성요소(building block)이다.
  - 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.

## 함수 선언

- 함수 선언(function declaration) 방식을 이용하면 함수를 만들 수 있다.
  - 함수 선언 방식은 함수 선언문이라고 부르기도 한다.

```javascript
function showMessage() {
  alert('안녕하세요!');
}
```

- `function`키워드, 함수 이름, 괄호로 둘러싼 매개변수를 차례로 써주면 함수를 선언할 수 있다.
  - 매개 변수가 여러 개 있다면 각 매개변수를 콤마로 구분해준다.
  - 이어서 함수를 구성하는 코드의 모임인 함수 본문(body)을 중괄호로 감싸 붙여준다.
- 새롭게 정의한 함수는 이름 옆에 괄호를 붙여 호출할 수 있다.

```javascript
function showMessage() {
  alert('안녕하세요!');
}
showMessage();
showMessage();
```

- 함수를 호출하면 함수 본문이 실행된다.
- 함수의 주요 용도 중 하나는 중복 코드 피하기이다.
- 얼럿 창에 보여줄 메시지를 바꾸거나 메시지를 보여주는 방식 자체를 변경하고 싶다면?
  - 함수 본문 중 출력에 관여하는 코드 딱 하나만 수정해주면 된다.

## 지역 변수

- 함수 내에서 선언한 변수인 지역 변수(local variable)는 함수 안에서만 접근할 수 있다.

```java
function showMessage() {
  let message = "안녕하세요!"; // 지역 변수

  alert(message);
}
showMessage(); // 안녕하세요!
alert( message ); // ReferenceError: message is not defined (message는 함수 내 지역 변수이기 때문에 에러 발생)
```

## 외부 변수

- 함수 내부에서 함수 외부의 변수인 외부 변수(outer variable)에 접근할 수 있다.

```javascript
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
```

- 접근 뿐만 아니라 수정도 할 수 있다.

```javascript
let userName = 'John';

function showMessage() {
  userName = "Bob"; // 외부 변수를 수정

  let message = 'Hello, ' + userName;
  alert(message);
}

alert(userName); // 함수 호출 전이므로 John 이 출력

showMessage();

alert(userName); // 함수에 의해 Bob 으로 값이 바뀜
```

- 외부 변수는 지역 변수가 없는 경우에만 사용할 수 있다.
- 함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 가린다.
  - 외부 변수는 내부 변수에 가려져 값이 수정되지 않는다.

```javascript
let userName = 'John';

function showMessage() {
  let userName = "Bob"; // 같은 이름을 가진 지역 변수 선언

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// 함수는 내부 변수인 userName만 사용합니다,
showMessage();

alert(userName); // John
```

- 함수 외부에 선언된 변수는 전역 변수(gloval variable)라고 부른다.
  - 전역 변수는 같은 이름을 가진 지역 변수에 의해 가려지지만 않는다면 모든 함수에서 접근할 수 있다.
- 변수는 연관되는 함수 내에 선언하고, 전역 변수는 되도록 사용하지 않는 것이 좋다.
  - 다만 프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있다.

## 매개변수

- 매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다.

```javascript
function showMessage(from, text) { // 인수: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello!
showMessage('Ann', "What's up?"); // Ann: What's up?
```

- 함수에 전달된 인자는 지역변수 `from`과 `text`에 복사된다.
  - 그 후 함수는 지역변수에 복사된 값을 사용한다.

```javascript
function showMessage(from, text) {
  from = '*' + from + '*'; // from 멋지게 꾸미기
  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// 함수는 복사된 값을 사용하기 때문에 바깥의 "from"은 값이 변경되지 않는다.
alert(from); // Ann
```

## 기본값

- 매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 된다.

```javascript
// showMessage(from, text)는 매개변수가 2개지만, 인수를 하나만 넣어서 호출할 수 있다.
showMessage("Ann");
```

- 두 번째 매개변수에 값을 전달하지 않았기 때문에 `text`엔 `undefined`가 할당될 뿐 에러가 발생하지 않는다.
  - 에러없이 "Ann: undefined"가 출력된다.
- 매개변수에 값을 전달하지 않아도 그 값이 `undefined`가 되지 않게 하려면 '기본값(default value)'을 설정해주면 된다.
  - 매개변수 오른쪽에 `=`을 붙이고 `undefined` 대신 설정하고자 하는 기본값을 써주면 된다.

```javascript
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

- 복잡한 표현식도 기본값으로 설정할 수도 있다.

```javascript
function showMessage(from, text = anotherFunction()) {
  // anotherFunction()은 text값이 없을 때만 호출된다.
  // anotherFunction()의 반환 값이 text의 값이 된다.
}
```

- 자바스크립트에선 함수를 호출할 때마다 매개변수 기본값을 평가한다.
  - 해당하는 매개변수가 없을 때만 기본값을 평가
- 바로 위의 코드에선 `text`에 값이 없는 경우 `showMessage()`를 호출할 때마다 `anotherFunction()`이 호출된다.

### 매개변수 기본값을 설정할 수 있는 또 다른 방법

- 함수 선언부에서 매개변수 기본값을 설정하는 것 대신 함수가 실행되는 도중 기본값을 설정하는 게 논리에 맞는 경우가 생기기도 한다.
  - 이럴 경우 일단 매개 변수를 `undefined`와 비교하여 함수 호출 시 매개변수가 생략되었는지를 확인한다.

```javascript
function showMessage(text) {
  if (text === undefined) {
    text = '빈 문자열';
  }
  alert(text);
}

showMessage(); // 빈 문자열
```

- `if`문을 쓰는 것 대신 논리 연산자 `||`을 사용할 수도 있다.

```javascript
// 매개변수가 생략되었거나 빈 문자열("")이 넘어오면 변수에 '빈 문자열'이 할당된다.
function showMessage(text) {
  text = text || '빈 문자열';
  ...
}
```

- 모던 자바스크립트 엔진이 지원하면 null 병합 연산자 `??`를 사용하면 `0`처럼 falsy로 평가되는 값들을 일반 값처럼 처리할 수 있어 좋다.

```javascript
// 매개변수 'count'가 넘어오지 않으면 'unknown'을 출력해주는 함수
function showCount(count) {
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

## 반환 값

- 함수를 호출했을 때 함수를 호출한 곳에 특정 값을 반환하게 할 수 있다.
  - 이때 이 특정 값을 반환 값(return value)이라고 부른다.

```javascript
// 인수로 받은 두 값을 더해주는 함수
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

- 지시자 `return`은 함수 내 어디서든 사용할 수 있다.
  - 실행 흐름이 지시자 `return`을 만나면 함수 실행은 즉시 중단되고 함수를 호출한 곳에 값을 반환한다.
  - 함수 하나에 여러 개의 `return`문이 올 수도 있다.

```javascript
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('보호자의 동의를 받으셨나요?');
  }
}

let age = prompt('나이를 알려주세요', 18);

if (checkAge(age)) {
  alert('접속 허용');
} else {
  alert('접속 차단');
}
```

- 지시자 `return`만 명시하는 것도 가능하다.
  - 이런 경우 함수가 즉시 종료된다.

```javascript
function showMovie(age) {
  if (!checkAge(age)) { // checkAge(age)가 false 반환시
    return; // 함수종료
  }

  alert("영화 상영"); // checkAge(age)가 false 반환시 실행 안됨
  // ...
}
```

- `return`문이 없거나 `return` 지시자만 있는 함수는 `undefined`를 반환한다.
  - 리턴문이 없는 함수도 무언가를 반환한다.
    - `undefined`를 반환.

```javascript
function doNothing() {
    /* empty */
}

alert(doNothing() === undefined); // true
//-----------------------------------------
function doNothing() {
  return;
}

alert(doNothing() === undefined); // true
```

- `return`과 값 사이에 절대 줄을 삽입하면 안된다.
  - 반환하려는 값이 긴 표현식인 경우, `return`과 반환하려는 값 사이에 새 줄을 넣어 코드를 작성하고 싶을 수도 있다.

```javascript
return
 (some + long + expression + or + whatever * f(a) + f(b))
```

- 자바스크립트는 return문 끝에 세미콜론을 자동으로 넣기 때문에 위에처럼 리턴문을 작성하면 안 된다.

```javascript
// 위 코드의 동작
return;
 (some + long + expression + or + whatever * f(a) + f(b))
```

- 반환하고자 했던 표현식을 반환하지 못하고 아무것도 반환하지 않는 것처럼 되어버린다.
- 표현식을 여러 줄에 걸쳐 작성하고 싶다면?
  - 표현식이 `return` 지시자가 있는 줄에서 시작하도록 작성해야 한다.
  - 또는 여는 괄호를 `return` 지시자와 같은 줄에 써줘도 괜찮다.

```javascript
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

## 함수 이름짓기

- 함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것
  - 따라서 함수의 이름은 대개 동사이다.
  - 함수 이름은 가능한 한 간결하고 명확해야 한다.
  - 함수가 어떤 동작을 하는지 설명할 수 있어야 한다.
  - 코드를 읽는 사람은 함수 이름만 보고도 함수가 어떤 기능을 하는지 힌트를 얻을 수 있어야 한다.
- 함수가 어떤 동작을 하는지 축약해서 설명해주는 동사를 접두어로 붙여 함수 이름을 만드는 게 관습
  - 다만, 팀 내에서 그 뜻이 반드시 합의된 접두어만 사용해야 한다.
  - `"show"`로 시작하는 함수는 대개 무언가를 보여주는 함수
- 접두어 사용 예시
  - `"get..."` - 값을 반환함
  - `"calc..."` - 무언가를 계산함
  - `"create"` - 무언가를 생성함
  - `"check..."` - 무언가를 확인하고 불린값을 반환함

```javascript
// 함수 만들기 예시
showMessage(..)     // 메시지를 보여줌
getAge(..)          // 나이를 나타내는 값을 얻고 그 값을 반환함
calcSum(..)         // 합계를 계산하고 그 결과를 반환함
createForm(..)      // form을 생성하고 만들어진 form을 반환함
checkPermission(..) // 승인 여부를 확인하고 true나 false를 반환함
```

---

- 함수는 동작 하나만 담당해야 한다.
  - 함수는 함수 이름에 언급되어 있는 동작을 정확히 수행해야 한다.
  - 그 이외의 동작은 수행해선 안 된다.
- 독립적인 두 개의 동작은 독립된 함수 두 개에서 나눠서 수행할 수 있게 해야 한다.
  - 한 장소에서 두 동작을 동시에 필요로 하는 경우라도(이 경우 제3의 함수를 만들어 그곳에서 두 함수를 호출)
- 빈번히 하는 실수 예시
  - `getAge` 함수는 나이를 얻어오는 동작만 수행해야 한다.
    - `alert`창에 나이를 출력해주는 동작은 이 함수에 들어가지 않는 것이 좋다.
  - `createForm` 함수는 form을 만들고 이를 반환하는 동작만 해야 한다.
    - form을 문서에 추가하는 동작이 해당 함수에 들어가 있으면 좋지 않다.
  - `checkPermission` 함수는 승인 여부를 확인하고 그 결과를 반환하는 동작만 해야 한다.
    - 승인 허가 여부를 보여준느 메시지를 띄우는 동작이 들어가 있으면 좋지 않다.
- 접두어를 붙여 만든 함수는 팀에서 만든 규칙을 반드시따라야 한다.

---

## 함수 == 주석

- 함수는 간결하고, 한 가지 기능만 수행할 수 있게 만들어야 한다.
  - 함수가 길어지면 함수를 잘게 쪼갤 때가 되었다는 신호로 받아들여야 한다.
  - 함수를 쪼개는 건 쉬운 작업은 아니다.
- 함수를 분리해 작성하면 많은 장점이 있기 때문에 함수가 길어질 경우 함수를 분리해 작성하는 것이 좋다.
  - 함수를 간결하게 만들면 테스트와 디버깅이 쉬워진다.
  - 함수 그 자체로 주석의 역할까지 한다.

```javascript
// 같은 동작을 하는 함수 showPrimes(n) 비교
function showPrimes(n) { // n 까지의 소수를 출력해준다.
  nextPrime:
  for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i); // 소수
  }
}
//-----------------------------------------------
// 소수인지 아닌지 여부를 검증하는 코드를 분리해 작성
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

- `isPrime` 함수 이름을 보고 해당 함수가 소수 여부를 검증하는 동작을 한다는 걸 쉽게 알 수 있다.
  - 이름만 보고도 어떤 동작을 하는지 알 수 있는 코드를 자기설명적(self-describing)코드라고 부른다.
  - 이렇게 함수는 중복을 없애려는 용도 외에도 사용할 수 있다.
- 함수를 활용하면 코드가 정돈되고 가독성이 높아진다.

# 함수 표현식

- 자바스크립트는 함수를 특별한 종류의 값으로 취급한다.
  - 다른 언어처럼 "특별한 동작을 하는 구조"로 취급되지 않는다.

```javascript
// 함수 선언문 방식으로 함수를 만들었을 때
function sayHi() {
  alert( "Hello" );
}
// 함수 표현식을 사용해서 함수를 만들 수 있다.
let sayHi = function() {
  alert( "Hello" );
};
```

- 함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었다.
  - 함수가 어떤 방식으로 만들어졌는지에 관계없이 함수는 값이고, 따라서 변수에 할당할 수 있다.
  - 위 예시에선 함수가 변수 `sayHi`에 저장된 값이 되었다.
  - 간단히 말로 풀면 : "함수를 만들고 그 함수를 변수 `sayHi`에 할당하기"
  - 함수는 값이기 때문에 `alert`을 이용해 함수 코드를 출력할 수도 있다.

```javascript
function sayHi() {
  alert( "Hello" );
}

alert(sayHi); // 함수 코드가 보임
```

- 마지막 줄에서 `sayHi`옆에 괄호가 없기 때문에 함수는 실행되지 않는다.
  - 어떤 언어에선 괄호 없이 함수 이름만 언급해도 함수가 실행되지만 자바스크립트는 괄호가 있어야만 함수가 호출된다.
- 자바스크립트에서 함수는 값이다.
  - 따라서 함수를 값처럼 취급할 수 있다.
- 함수는 `sayHi()`처럼 호출할 수 있다는 점 때문에 일반적인 값과는 조금 다르다.
  - 특별한 종류의 값
  - 하지만 그 본질은 값이기 때문에 값에 할 수 있는 일을 함수에도 할 수 있다.
- 변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있다.

```javascript
function sayHi() {   // (1) 함수 생성
  alert( "Hello" );
}

let func = sayHi;    // (2) 함수 복사

func(); // Hello     // (3) 복사한 함수를 실행
sayHi(); // Hello    //     본래 함수도 정상적으로 실행
```

1. (1)에서 함수 선언 방식을 이용해 함수를 생성한다.
   - 생성한 함수는 `sayHi`라는 변수에 저장된다.
2. (2)에선 `sayHi`를 새로운 변수 `func`에 복사한다. 이 때 `sayHi` 다음에 괄호가 없다는 것에 유의
   - 괄호가 있었다면 `func = sayHi()`가 되어 `sayHi`함수 그 자체가 아니라, 함수 호출 결과(반환값)가 `func`에 저장된다.
3. `sayHi()`와 `func()`로 함수를 호출할 수 있다.

```javascript
// 함수 sayHi는 함수 표현식을 사용해 정의할 수 있다.
let sayHi = function() {
  alert( "Hello" );
};

let func = sayHi;
// ...
```

---

- 함수 표현식의 끝에 세미 콜론 `;`이 왜 붙을까?
  - `if {...}`, `for { }`, `function f { }`같이 중괄호로 만든 코드 블록 끝엔 `;`이 없어도 된다.
  - 함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 한다.  
    코드 블록이 아니고 값처럼 취급되어 변수에 할당되기 때문.  
    그러므로 모든 구문의 끝엔 세미 콜론을 붙이는 게 좋다.
  - 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라 구문의 끝이기 때문에 붙여졌다.

---

## 콜백 함수

- 매개 변수가 3개 있는 함수인 `ask(question, yes, no)`를 작성한다고 가정
  - `question` : 질문
  - `yes` : "Yes"라고 답한 경우 실행되는 함수
  - `no` : "No"라고 답한 경우 실행되는 함수
- 함수는 반드시 question(질문)을 해야 하고, 사용자의 답변에 따라 `yes()`나 `no()`를 호출한다.

```javascript
function ask(question, yes, no) {
  if (confirm(question)) {
      yes();
  } else {
      no();
  }
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);
```

- 함수 `ask`의 인수인 `showOk`와 `showCancel`은 콜백 함수 또는 콜백이라고 불린다.
  - 함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 나중에 호출(called back)하는 것이 콜백 함수의 개념
  - 위의 예시에서 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고,  
    "no"라고 대답한 경우 `showCancel`가 콜백이 된다.
- 함수 표현식을 사용하면 코드 길이가 짧아진다.

```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

- 위처럼 이름 없이 선언한 함수는 익명 함수라고 부른다.
  - 익명 함수는 변수에 할당된 게 아니기 때문에 `ask` 바깥에선 접근할 수 없다.

---

- 함수는 "동작"을 나타내는 값이다.
  - 문자열이나 숫자 등의 일반적인 값들은 데이터를 나타낸다.
  - 함수는 하나의 동작을 나타낸다.
  - 동작을 대변하는 값인 함수를 변수 간 전달하고, 동작이 필요할 때 이 값을 실행할 수 있다.

---

## 함수 표현식 vs 함수 선언문

- 함수 표현식과 선언문의 차이

  1. 문법

     - 함수 선언문 : 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재한다. 

       ```javascript
       // 함수 선언문
       function sum(a, b) {
         return a + b;
       }
       ```

     - 함수 표현식 : 함수는 표현식이나 구문 구성 내부에 생성된다.

       ```javascript
       // 함수 표현식
       let sum = function(a, b) { // 할당 연산자 = 를 이용해 만든 할당 표현식 우측에 생성되었다.
         return a + b;
       };
       ```

  2. 자바스크립트 엔진이 언제 함수를 생성하는지

     - 함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다.  
       따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다.
       - 예시에서는 실행 흐름이 `let sum = function...`의 우측(함수표현식)에 도달했을 때 함수가 생성된다.
       - 이때 이후부터 해당 함수를 사용할 수 있다.
     - 함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있다.
       - 전역 함수 선언문은 스크립트 어디에 있느냐에 상관없이 어디에서든 사용할 수 있다.
       - 가능한 이유
         - 자바스크립트의 내부 알고리즘 때문
         - 자바스크립트는 스크립트르 실행하기 전, 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성한다.
         - 스크립트가 진짜 실행되기 전 "초기화 단계"에서 함수 선언 방식으로 정의한 함수가 생성된다.
         - 스크립트는 함수 선언문이 모두 처리된 이후에서야 실행된다.  
           따라서 스크립트 어디에서든 함수 선언문으로 선언한 함수에 접근할 수 있다.

     ```javascript
     // 예시
     sayHi("John"); // Hello, John
     
     function sayHi(name) {
       alert( `Hello, ${name}` );
     }
     ```

     - 함수 선언문 `sayHi`는 스크립트 실행 준비 단계에서 생성되기 때문에 스크립트 어디에서든 접근할 수 있다.
       - 그러나 함수 표현식으로 정의한 함수는 함수가 선언되기 전에 접근하는 게 불가능하다.

     ```javascript
     sayHi("John"); // error
     
     let sayHi = function(name) { // (*)
       alert( `Hello, ${name}` );
     };
     ```

     - 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다.
       - `(*)`로 표시한 줄에 실행 흐름이 도달했을 때 함수가 만들어진다.

  3. 스코프
     - 엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다.  
       하지만 블록 밖에서는 함수에 접근하지 못한다.
       - 만약 런타임에 그 값을 알 수 있는 변수 `age`가 있고,  
         이 변수의 값에 따라 함수 `welcome()`을 다르게 정의해야 하는 상황이고  
         `welcome()`은 나중에 사용해야 하는 상황이라면?
         - 함수 선언문을 사용하면 의도한 대로 코드가 동작하지 않는다.

```javascript
let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {

  function welcome() {
    alert("안녕!");
  }

} else {

  function welcome() {
    alert("안녕하세요!");
  }

}

// 함수를 나중에 호출
welcome(); /* Error: welcome is not defined
함수 선언문은 함수가 선언된 코드 블록 안에서만 유효하기 때문*/
```

```javascript
let age = 16; // 16을 저장했다 가정

if (age < 18) {
  welcome();               // \   (실행)
                           //  |
  function welcome() {     //  |
    alert("안녕!");        //  |  함수 선언문은 함수가 선언된 블록 내
  }                        //  |  어디에서든 유효
                           //  |
  welcome();               // /   (실행)

} else {

  function welcome() {
    alert("안녕하세요!");
  }
}

// 여기는 중괄호 밖이기 때문에
// 중괄호 안에서 선언한 함수 선언문은 호출할 수 없다.

welcome(); // Error: welcome is not defined
```

- `if`문 밖에서 `welcome` 함수를 호출할 방법은 없을까?
  - 함수 표현식을 사용하면 가능하다.
  - `if`문 밖에 선언한 변수 `welcome`에 함수 표현식으로 만든 함수를 할당하면 된다.

```javascript
let age = prompt("나이를 알려주세요.", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("안녕!");
  };

} else {

  welcome = function() {
    alert("안녕하세요!");
  };

}

welcome(); // 제대로 동작
```

- 물음표 연산자 `?` 를 사용하면 좀 더 단순화 할 수 있다.

```javascript
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  function() { alert("안녕!"); } :
  function() { alert("안녕하세요!"); };

welcome(); // 제대로 동작
```

---

- 함수 선언문과 함수 표현식 중 무엇을 선택해야 할까?
  - 함수 선언문을 이용햐 함수를 선언하는 걸 먼저 고려하는 게 좋다.
    - 함수 선언문으로 함수를 정의하면, 함수가 선언되기 전에도 호출할 수 있어 코드 구성을 좀 더 자유롭게 할 수 있다.
    - 함수 선언문을 사용하면 가독성도 좋아진다. (더 눈길을 사로잡는다.)
  - 그러나 어떤 이유로 함수 선언 방식이 적합하지 않거나, 조건에 따라 함수를 선언해야 한다면?
    - 함수 표현식을 사용해야 한다.

---

# 화살표 함수 기초

- 함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있는 방법이 있다.
  - 화살표 함수(arrow function)를 사용하는 것.

```javascript
let func = (arg1, arg2, ...argN) => expression
// 인자 arg1 .. argN 를 받는 함수 func 가 만들어진다.
// 함수 func는 화살표(=>) 우측의 표현식(expression)을 평가하고, 평가 결과를 반환한다.

// 아래 함수의 축약 버전
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

- 더 구체적인 예시

```javascript
let sum = (a, b) => a + b;

/* 위 화살표 함수는 아래 함수의 축약 버전
let sum = function(a, b) {
  return a + b;
};
*/

alert(sum(1, 2)); // 3
```

- `(a, b) => a + b`는 인수 a와 b를 받는 함수이다.
  - 실행되는 순간 표현식 `a + b`를 평가하고 그 결과를 반환한다.
- 인수가 하나밖에 없다면 감싸는 괄호를 생략할 수 있다.

```javascript
let double = n => n * 2;
// let double = function(n) { return n * 2 }과 거의 동일

alert(double(3)); // 6
```

- 인수가 하나도 없을 땐 괄호를 비워놓으면 된다.
  - 다만 이 때는 괄호는 생략할 수 없다.

```javascript
let sayHi = () => alert("안녕하세요!");

sayHi();
```

- 화살표 함수는 함수 표현식과 같은 방법으로 사용할 수 있다.
  - 함수를 동적으로 만들 수 있다.

```javascript
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  () => alert('안녕') :
  () => alert("안녕하세요!");

welcome();
```

- 화살표 함수를 처음 접하면 익숙하지 않기 때문에 가독성이 떨어진다.
  - 하지만 문법이 눈에 익기 시작하면 적응은 식은 죽 먹기가 된다.
- 함수 본문이 한 줄인 간단한 함수는 화살표 함수를 사용해서 만드는 게 편리하다.
  - 타이핑을 적게 해도 함수를 만들 수 있다는 장점이 있다.

## 본문이 여러 줄인 화살표 함수

- 평가해야 할 표현식이나 구문이 여러 개인 함수가 있을 수도 있다.
  - 이 경우도 화살표 함수 문법을 사용해 함수를 만들 수 있다.
  - 하지만 이때는 중괄호 안에 평가해야 할 코드를 넣어주어야 한다.
  - 그리고 `return` 지시자를 사용해 명시적으로 결과값을 반환해 주어야 한다.

```javascript
let sum = (a, b) => {  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려준다.
  let result = a + b;
  return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 한다.
};

alert(sum(1, 2)); // 3
```

