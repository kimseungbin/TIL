# 원시값의 메서드

- 자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.
- 원시값에서도 객체에서처럼 메서드를 호출할 수 있다.
- 원시값과 객체의 차이
  - 원시값 :
    - 원시형의 값
    - 종류로는 문자(string), 숫자(number), bigint, 불린(boolean), 심볼(symbol), null, undefined 형으로 총 일곱가지
  - 객체 : 
    - 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
    - 대괄호 `{}`를 사용해 만들 수 있다.  
      함수도 객체의 일종
- 객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것이다.

```javascript
let john = {
    name: "John",
    sayHi: function() {
        alert("친구야 반갑다!");
    },
};

john.sayHi(); // 친구야 반갑다!
```

- 자바스크립트는 날짜, 오류, HTML 요소 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공한다.
  - 이 객체들은 고유한 프로퍼티와 메서드를 가진다.
  - 하지만 이런 기능을 사용하면 시스템 자원이 많이 소모된다.
    - 객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문

## 원시값을 객체처럼 사용하기

- 자바스크립트 창안자는 아래와 같은 모순적인 상황을 해결해야만 했다.
  - 문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각이 든다.
  - 그런데 원시값은 가능한 한 빠르고 가벼워야 한다.
- 자바스크립트 창안자는 아래와 같은 방법을 사용해 해결책을 모색했다.
  1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
  2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
  3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체인  
     원시 래퍼 객체(object wrapper)를 만들어준다. 이 객체는 곧 삭제된다.
- 래퍼 객체는 원시 타입에 따라 종류가 다양하다.
  - 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`, `Number`, `Boolean`, `Symbol` 이라고 부른다.
  - 래퍼 객체마다 제공하는 메서드 역시 다르다.

```javascript
// 인수로 받은 문자열의 모든 글자를 대문자로 바꿔주는 메서드 str.toUpperCase()의 예
let str = "Hello";

alert(str.toUpperCase()); // HELLO
```

- `str.toUpperCase()`가 호출될 때 내부에서 실제로 일어나는 일
  1. 문자열 `str`은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어진다.
     - 이 객체는 문자열의 값을 알고 있고, `toUpperCase()`와 같은 유용한 메서드를 가지고 있다.
  2. 메서드가 실행되고, 새로운 문자열이 반환된다.
  3. 특별한 객체는 파괴되고, 원시값 `str`만 남는다.
     - 이러한 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있다.
- 자바스크립트 엔진은 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게끔 해준다.
- 숫자형도 고유한 메서드를 지원한다.

```javascript
// 메서드 toFixed(n)을 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할 수 있다.
let n = 1.23456;

alert(n.toFixed(2)); // 1.23
```

---

- `String / Number / Boolean` 를 생성자론 쓰지 말자.
  - Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 래퍼객체를 직접 만들 수 있다.
  - 자바스크립트에서도 하위 호완성을 위해 이 기능을 남겨 두었는데, 이런 식으로 래퍼 객체를 만드는 건 추천하지 않는다.
    - 몇몇 상황에서 혼동을 불러일으키기 때문

```javascript
// 예시
alert(typeof 0); // "number"

alert(typeof new Number(0)); // "object"
```

- 객체는 논리 평가 시 항상 참을 반환한다.

```javascript
// 얼럿창은 무조건 열린다.
let zero = new Number(0);

if (zero) { // 변수 zero는 객체이므로 조건문이 참이 된다.
    alert("...");
}
```

- `new`를 붙이지 않고, `String / Number / Boolean`를 사용하는 건 괜찮다.
  - `new`없이 사용하면 상식에 맞게 인수를 원하는 형의 원시값(문자열, 숫자, 불린 값)으로 바꿔준다.

```javascript
let num = Number("123"); // 문자열을 숫자로 바꿔줌
```

- `null / undefined`는 메서드가 없다.
  - 특수 자료형인 `null`과 `undefined`의 자료형과 연관되는 래퍼 객체도 없고, 메서드도 제공하지 않는다.
  - 두 자료형이 가장 원시적이라 할 수 있다.

```javascript
// 두 자료형이 속한 값의 프로퍼티에 접근하려 하면 에러가 발생한다.
alert(null.test); // error
```

# 숫자형

- 모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다.
  1. 일반적인 숫자는 배정밀도 부동소수점 숫자(double precision floating point number)로 알려진 64비트 형식의 IEEE-754에 저장된다.
     - IEEE-754 : IEEE에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준
  2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다.
     - 일반적인 숫자는 2<sup>53</sup>이상이거나 -2<sup>53</sup>이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다.
     - BigInt는 아주 특별한 경우에만 사용된다.

## 숫자를 입력하는 다양한 방법

- 10억을 입력해야 한다고 상상해보자.
  - 가장 분명한 방법은 직접 10억을 써주는 것이다.

```javascript
let billion = 1000000000;
```

- 그런데 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않는다.
  - 대개는 10억(billion)을 나타낼 땐 '1bn'을 사용하고, 73억을 나타낼 땐 '7.3bn'을 사용한다.
  - 자바스크립트에서도 숫자 옆에 'e'를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9; // 10억, 1과 9개의 0

alert(7.3e9); // 73억
```

- 'e'는 왼쪽의 수에 e  오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

- 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현한다면

```javascript
let ms = 0.000001;
```

- 작은 숫자를 표현할 때도 'e'를 사용할 수 있다.

```javascript
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

- `0.000001`에서 0의 개수를 세면 6이므로 `0.000001`은 `1e-6`이 된다.
  - `e`우측에 음수가 있으면, 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미한다.

```javascript
// 10을 세 번 거듭제곱한 수로 나눔
1e-3 = 1 / 1000 (=0.001)

// 10을 여섯 번 거듭제곱한 수로 나눔
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

### 16진수, 2진수, 8진수

- 16진수는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰인다.
  - 16진수는 `0x`를 사용해 표현할 수 있다.

```javascript
alert(0xff); // 255
alert(oxFF); // 255 (대, 소문자를 가리지 않는다.)
```

- 2진수와 8진수는 아주 드물게 쓰이긴 하지만 접두사 `0b`와 `0o`를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, 진법은 다르지만 a와 b는 같은 수이기 때문
```

- 자바스크립트에서 지원하는 진법은 3개이다.
  - 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다.

## toString(base)

- `num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.

```javascript
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

- `base`는 `2`에서 `36`까지 쓸 수 있고, 기본값은 `10`이다.
- `base`별 유스 케이스
  - base = 16 - 16진수 색, 문자 인코딩 등을 표현할 때 사용. 숫자는 0부터 9, 10이상의 수는 A부터 F를 사용하여 나타낸다.
  - base = 2 - 비트 연산 디버깅에 주로 쓰인다. 숫자는 0 또는 1이 될 수 있다.
  - base = 36 - 사용할 수 있는 base 중 최댓값으로, `0...9`와 `A...Z`를 사용해 숫자를 표현한다.  
    알파벳 전체가 숫자를 나타내는 데 사용된다. `36`베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다.

```javascript
alert(123456..toString(36)); // 2n9c
```

- 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음 점 두개`..`를 붙여야 한다.
  - 점을 한 개만 사용하면 첫 번째 점 이후로는 소수부로 인식되어 에러가 발생한다.
  - 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.
  - `(123456).toString(36)`도 가능하다.

## 어림수 구하기

- 어림수를 구하는 것은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

- `Math.floor`

  - 소수점 첫째 자리에서 내림(버림). `3.1`은 `3`, `-1.1`은 `-2`가 된다.

- `Math.ceil`

  - 소수점 첫째 자리에서 올림. `3.1`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.round`

  - 소수점 첫째 자리에서 반올림. `3.1`은 `3`, `3.6`은 `4`, `-1.1`은 `-1`이 된다.

- `Math.trunc` (IE는 지원X)

  - 소수부를 무시. `3.1`은 `3`이 되고 `-1.1`은 `-1`이 된다.

- 소수점 `n-th`번째 수를 기준으로 어림수를 구해야 하는 상황이라면?

  - ex) `1.2345`가 있는데, 소수점 두 번째 자리수까지만 남겨 `1.23`을 만들고 싶은 경우

    1. 곱하기와 나누기

       - 소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100을 곱한 후, 원하는 어림수 내장 함수 호출하고 다시 100으로 나눈다.  

         ```javascript
         let num = 1.23456;
         
         alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
         ```

    2. 소수점 `n`번째 수까지의 어림수를 구한 후 이를 문자형으로 변환해주는 메서드인 toFixed(n)을 사용한다.  

       ```javascript
       let num = 12.34;
       alert(num.toFixed(1)); // "12.3"
       ```

       - `toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해준다.

       ```javascript
       let num = 12.36;
       alert( num.toFixed(1) ); // "12.4"
       ```

       - `toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것.  
         소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.  

         ```javascript
         let num = 12.34;
         alert(num.toFixed(5)); // "12.34000", 소수부의 길이를 5로 만든다.
         ```

       - `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있다.

## 부정확한 계산

- 숫자는 내부적으로 64비트 형식 IEEE-754 으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다.
  - 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는0), 1비트는 부호를 저장하는데 사용된다.
  - 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert(1e500); // Infinity
```

- 자주 발생하는 현상인 정밀도 손실 예시

```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
```

- 0.1과 0.2의 합이 0.3과 일치할탠데 false가 출력되었다.

```javascript
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

- 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다.
  - 그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2`같은 분수는 이진법으로 표현하면 무한 소수가 된다.
  - `0.1`은 1을 10으로 나눈 수인 `1/10`인데, 10진법을 사용하면 쉽게 표현할 수 있다. `1/3`은 무한 소수가 된다.
  - 이렇게 10의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 3으로 나누게 되면 10진법에서 제대로 동작하지 않는다.
  - 같은 이유로 2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버린다.
  - 10진법에서 1/3을 정확히 나타낼 수 없듯, 2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없다.
  - IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다.
    - 그런데 반올림 규칙을 적용하면 발생하는 작은 정밀도 손실이 발생한다.

```javascript
// 정밀도 손실을 눈으로 볼 수 있는 코드
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

- 두 숫자를 합하면 정밀도 손실도 더해지게 된다.
  - 0.1 + 0.2가 정확히 0.3이 아닌 이유가 이것때문.
  - 다른 언어에서도(PHP, Java, C, Perl, Ruby) 똑같은 결과를 얻는다.
- 해결하는 방법은?
  - 가장 신뢰할만한 방법은 toFixed(n) 메서드를 사용해 어림수를 만드는 것

```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

- toFixed는 항상 문자열을 반환한다는 점에 유의해야 한다.
  - 그렇기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3 덧셈연산자를 사용해 숫자형으로 강제 변환
```

- 숫자에 임시로 100(또는 더 큰 숫자)을 곱해서 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있다.
  - 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문
  - 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.

```javascript
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

- 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는것은 오류를 줄여주긴 하지만 완전히 없애지는 못한다.
- 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우, 무한 소수를 방지하는 완벽한 방법은 없다.
  - 필요할 때마다 꼬리를 잘라 어림수를 만드는 방법뿐이다.

## isNaN과 isFinite

- `Infinity`와 `-Infinity` : 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` : 에러를 나타내는 값
- 두개의 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.
  - `isNaN(value)` : 인수를 숫자로 변환한 다음 `NaN`인지 테스트

```javascript
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```

- `=== NaN` 비교를 하면 되지 않을까?
  - NaN은 NaN 자기 자신을 포함해서 그 어떤 값과도 같지 않다는 점에서 독특하다.

```javascript
alert( NaN === NaN ); // false
```

- `isFinite(value)` : 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환한다.

```javascript
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false
alert( isFinite(Infinity) ); // false
```

- `isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요.", '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력
alert( isFinite(num) );
```

- 빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점에 유의하자.

---

- `Object.is`는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 두 가지 에지케이스에서 `===`보다 신뢰할만한 결과를 보여준다.

  1. `NaN`을 대상으로 비교할 때 : `Object.is(NaN, NaN) === true`
  2. `0`과 `-0`이 다르게 취급되어야 할 때 : `Object.is(0, -1) === false`

  - 두 가지 에지 케이스를 제외하고는 `Object.is(a, b)`와 `a === b`의 결과는 같다.

---

## parseInt와 parseFloat

- 단항 덧셈 연산자 `+`또는 `Number()`를 사용해 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다.
  - 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert( +"100px" ); // NaN
```

- 엄격한 규칙이 적용되지 않는 유일한 예외
  - 처음 또는 끝에 공백이 있어서 공백을 무시할 때
- 실무 CSS 등에서 `100px`, `12pt`와 같이 숫자와 단위를 같이 쓰는 경우가 흔하다.
  - 금액 뒤에 통화 기호를 붙여 표시하기도 하기 때문에 숫자만 추출하는 방법이 필요하다.
- 내장함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌다.
  - 두 함수는 불가능할 때까지 문자열에서 숫자를 읽는다.
  - 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다.
  - `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

- 읽을 수 있는 숫자가 없을 때 `NaN`을 반환할 때도 있다.

```javascript
alert( parseInt('a123') ); // NaN, a는 숫자가 아니다.
```

---

- `parseInt(str, radix)`의 두 번째 인수
  - `parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다.
  - `radix`는 원하는 진수를 지정해 줄 때 사용한다.
  - 따라서 `parseInt()`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있다.

```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, 0x가 없어도 동작

alert( parseInt('2n9c', 36) ); // 123456
```

---

## 기타 수학 함수

- 자바스크립트에서 제공하는 내장 객체 Math엔 다양한 수학 관련 함수와 상수들이 들어있다.
- `Math.random()`
  - 0과 1 사이의 난수를 반환(1은 제외)

```javascript
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (무작위 수)
```

- `Math.max(a, b, c, ...)` / `Math.min(a, b, c, ...)`
  - 인수 중 최대/최솟값을 반환한다.

```javascript
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
```

- `Math.pow(n, power)`
  - `n`을 power번 거듭제곱한 값을 반환

```javascript
alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
```

